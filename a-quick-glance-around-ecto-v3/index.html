<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2020-07-07 Tue 19:40 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>A Quick Glance Around Ecto v3</title>
<meta name="generator" content="Org mode">
<meta name="author" content="c4710n">
<meta name="description" content="Learn Ecto v3 in a fast way."
>
<meta name="keywords" content="Elixir, Erlang, Ecto, Phoenix, Tutorial, Book">
<link rel="stylesheet" type="text/css" href="../css/org-html-style.css" />
  <header class="header">
    <div class="logo-wrapper">
      <span class="logo">ECTO</span>
    </div>
    <button class="toc-trigger">TOC</button>
  </header>
</head>
<body>
<div id="content">
<header>
<h1 class="title">A Quick Glance Around Ecto v3</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org39610ab">1. Introduction</a></li>
<li><a href="#org7c5f72d">2. Prerequisites</a></li>
<li><a href="#org165ee54">3. The Conventions</a>
<ul>
<li><a href="#orgd9bb627">3.1. Plain English</a></li>
<li><a href="#orgb0451fa">3.2. Notation of shell commands</a></li>
<li><a href="#orgc8a506c">3.3. Reading official documents</a></li>
</ul>
</li>
<li><a href="#org72179fe">4. Setup Environments</a></li>
<li><a href="#org6a4e917">5. Sample Application</a>
<ul>
<li><a href="#org7b1afcf">5.1. Creating a mix project</a></li>
<li><a href="#org0228804">5.2. Adding dependencies</a></li>
<li><a href="#orgba8d64d">5.3. Creating a Repo</a></li>
<li><a href="#org0722567">5.4. Adding Repo to supervision tree</a></li>
<li><a href="#org33b92f4">5.5. Adding configurations</a></li>
<li><a href="#orgb5b2588">5.6. Creating database</a></li>
<li><a href="#org4091eae">5.7. (optional) Updating configurations for <code>mix format</code></a></li>
<li><a href="#orgbb461df">5.8. Last</a></li>
</ul>
</li>
<li><a href="#sample-data-model">6. Sample Data Model</a></li>
<li><a href="#orgc637e3f">7. The Structure Of Ecto</a></li>
<li><a href="#org5a88c7e">8. <code>Ecto.Migration</code></a>
<ul>
<li><a href="#org1f3f0d6">8.1. What is a migration?</a></li>
<li><a href="#org6b19ddf">8.2. Generating template for migrations</a></li>
<li><a href="#creating-migrations">8.3. Creating migrations</a></li>
<li><a href="#org7fc57a8">8.4. Applying migrations</a></li>
<li><a href="#org99b441d">8.5. Rolling back migrations</a></li>
<li><a href="#org4eef55b">8.6. Available column types</a></li>
<li><a href="#org8220ed7">8.7. Adding index</a></li>
<li><a href="#the-options-of-references">8.8. The options of <code>references</code></a></li>
<li><a href="#orga7180ea">8.9. Practices</a></li>
<li><a href="#orgaa5fe85">8.10. Last</a></li>
</ul>
</li>
<li><a href="#org9d8c5e4">9. <code>Ecto.Repo</code></a>
<ul>
<li><a href="#orgc75a026">9.1. The Repository Pattern</a></li>
<li><a href="#orga7786eb">9.2. Repository in Ecto</a></li>
<li><a href="#orgedbd1a7">9.3. Low level API for CRUD</a></li>
<li><a href="#org26dc889">9.4. Extending Repo</a></li>
<li><a href="#org297f0fe">9.5. Last</a></li>
</ul>
</li>
<li><a href="#org409fe4a">10. <code>Ecto.Schema</code></a>
<ul>
<li><a href="#org6c49d1d">10.1. Creating schemas</a></li>
<li><a href="#org29c76d1">10.2. Starting IEx</a></li>
<li><a href="#org931fe6e">10.3. CRUD</a></li>
<li><a href="#orga35a01b">10.4. Last</a></li>
</ul>
</li>
<li><a href="#orgc0adbf0">11. <code>Ecto.Changeset</code></a>
<ul>
<li><a href="#org119f58f">11.1. About <code>%Ecto.Changeset{}</code></a></li>
<li><a href="#org4c7b9c8">11.2. Basics</a></li>
<li><a href="#org1611e12">11.3. Casting and Filtering</a></li>
<li><a href="#org1e53527">11.4. Validating</a></li>
<li><a href="#org67061b9">11.5. Send Changes to database</a></li>
<li><a href="#orgf19b711">11.6. Last</a></li>
</ul>
</li>
<li><a href="#orgc4eb9c0">12. <code>Ecto.Query</code></a>
<ul>
<li><a href="#org536b7d6">12.1. Syntax</a></li>
<li><a href="#org78a6ba8">12.2. Basic usage</a></li>
<li><a href="#orgf377eae">12.3. Debugging</a></li>
<li><a href="#org9ffdbf1">12.4. Dynamic values</a></li>
<li><a href="#org94dcae8">12.5. Query bindings</a></li>
<li><a href="#org2e18714">12.6. Query API</a></li>
<li><a href="#org796ecfe">12.7. Raw SQL</a></li>
<li><a href="#org1e3beb2">12.8. Filtering with <code>where</code></a></li>
<li><a href="#orgb931eee">12.9. Combining results with unions</a></li>
<li><a href="#orge140c4d">12.10. Ordering with <code>order_by</code></a></li>
<li><a href="#org5fc1496">12.11. Grouping with <code>group_by</code></a></li>
<li><a href="#org25f77eb">12.12. Joins</a></li>
<li><a href="#orgdd0e001">12.13. Composable Queries</a></li>
<li><a href="#orgeeca1dd">12.14. Using a schema</a></li>
<li><a href="#orge9b2712">12.15. Tips</a></li>
<li><a href="#orgd8c50e4">12.16. Last</a></li>
</ul>
</li>
<li><a href="#orgdaf96ed">13. Associations</a>
<ul>
<li><a href="#org3867564">13.1. Insert / Update</a></li>
<li><a href="#org28e84e9">13.2. Query</a></li>
<li><a href="#orgd2734bd">13.3. Delete</a></li>
</ul>
</li>
<li><a href="#orgad8b6e7">14. Transactions</a>
<ul>
<li><a href="#orgdedb4fb">14.1. with a function</a></li>
<li><a href="#org18f3bc6">14.2. with <code>Ecto.Multi</code></a></li>
<li><a href="#org5c40200">14.3. which one should I use?</a></li>
<li><a href="#orgc7b723f">14.4. executing non-database operations</a></li>
<li><a href="#org3796a09">14.5. introspecting <code>Ecto.Multi</code></a></li>
</ul>
</li>
<li><a href="#org99a7e24">15. Seeding</a>
<ul>
<li><a href="#orgafdabb4">15.1. Handling uniqueness</a></li>
<li><a href="#orga5143d2">15.2. Populate data with Schema</a></li>
</ul>
</li>
<li><a href="#orgf110568">16. Appendix</a>
<ul>
<li><a href="#org1c83038">16.1. Naming conventions</a></li>
<li><a href="#org79f6a91">16.2. Related Mix tasks</a></li>
<li><a href="#org2722025">16.3. Schema related tips</a></li>
<li><a href="#org90936fd">16.4. About timestamps</a></li>
<li><a href="#org84a4b01">16.5. Setting default value for fields?</a></li>
<li><a href="#orgee27fb3">16.6. Commonly used constraints</a></li>
<li><a href="#org866bc11">16.7. Don't use constraints all the time</a></li>
</ul>
</li>
<li><a href="#orgafc3963">17. License</a></li>
</ul>
</div>
</nav>
<p>
In order to help more people in Elixir community, I organize my personal notes, and publish them as a free online book.
</p>

<p>
Hope you guys like it!
</p>

<div id="outline-container-org39610ab" class="outline-2">
<h2 id="org39610ab"><span class="section-number-2">1</span> <a href="#org39610ab">Introduction</a></h2>
<div class="outline-text-2" id="text-1">
<p>
Ecto is the most popular persistence framework in Elixir Community.
</p>

<p>
In this book, we will glance over the main features of Ecto v3 by trying to construct the database layer of a blogging system.
</p>

<div class="question">
<p>
Why do you take a blogging system as the example?
</p>

<p>
A blogging system is the system that everybody knows. Readers don't have to spend time to learn domain-specific things.
</p>

</div>

<p>
If you want to have a deep insight of Ecto or more complicated use case, you can read more in <a href="https://hexdocs.pm/ecto/">Ecto's Docs</a> or <a href="https://pragprog.com/book/wmecto/programming-ecto">Programming Ecto</a>.
</p>
</div>
</div>

<div id="outline-container-org7c5f72d" class="outline-2">
<h2 id="org7c5f72d"><span class="section-number-2">2</span> <a href="#org7c5f72d">Prerequisites</a></h2>
<div class="outline-text-2" id="text-2">
<p>
Before reading this book, you should know how to write basic Elixir. That's all.
</p>
</div>
</div>

<div id="outline-container-org165ee54" class="outline-2">
<h2 id="org165ee54"><span class="section-number-2">3</span> <a href="#org165ee54">The Conventions</a></h2>
<div class="outline-text-2" id="text-3">
<p>
Conventions reduce the effort needed to read and understand.
</p>
</div>

<div id="outline-container-orgd9bb627" class="outline-3">
<h3 id="orgd9bb627"><span class="section-number-3">3.1</span> <a href="#orgd9bb627">Plain English</a></h3>
<div class="outline-text-3" id="text-3-1">
<p>
In order to help people as much as possible, I am trying to write this book in 7th-grade plain English.
</p>

<blockquote>
<p>
English isn't my mother language. When you find any error, it would be nice if you can <a href="mailto:c4710n@pm.me">email me</a> or create an issue.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgb0451fa" class="outline-3">
<h3 id="orgb0451fa"><span class="section-number-3">3.2</span> <a href="#orgb0451fa">Notation of shell commands</a></h3>
<div class="outline-text-3" id="text-3-2">
<p>
The shell commands is prefixed by <code>$</code> which is the default prompt for ordinary UNIX users.
</p>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ ls -al ~
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc8a506c" class="outline-3">
<h3 id="orgc8a506c"><span class="section-number-3">3.3</span> <a href="#orgc8a506c">Reading official documents</a></h3>
<div class="outline-text-3" id="text-3-3">
<p>
When something has been explained in official documents, it won't be described again. I will guide you to read the related documents.
</p>

<p>
For example, when you see something like <i>please read <code>h Ecto.Schema</code></i>, it means:
</p>
<ul class="org-ul">
<li>read docs in a terminal by typing <code>h Ecto.Schema</code> in IEx.</li>
<li>read docs in a web browser by visiting <a href="https://hexdocs.pm/ecto/Ecto.Schema.html">Ecto.Schema</a>.</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org72179fe" class="outline-2">
<h2 id="org72179fe"><span class="section-number-2">4</span> <a href="#org72179fe">Setup Environments</a></h2>
<div class="outline-text-2" id="text-4">
<p>
Before moving on, we should ensure that fundamental environments are configured:
</p>
<ul class="org-ul">
<li>Elixir 1.10+ is installed</li>
<li>PostgreSQL is installed</li>
</ul>

<p>
There are lots of online tutorials about setting up environments, we won't describe them again.
</p>
</div>
</div>

<div id="outline-container-org6a4e917" class="outline-2">
<h2 id="org6a4e917"><span class="section-number-2">5</span> <a href="#org6a4e917">Sample Application</a></h2>
<div class="outline-text-2" id="text-5">
<p>
Ecto is an Elixir library, it should be used in an Elixir project. Therefore, we should create a project before playing with Ecto.
</p>
</div>

<div id="outline-container-org7b1afcf" class="outline-3">
<h3 id="org7b1afcf"><span class="section-number-3">5.1</span> <a href="#org7b1afcf">Creating a mix project</a></h3>
<div class="outline-text-3" id="text-5-1">
<p>
Create a project called <code>paper</code>:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix new paper --sup
</pre>
</div>

<p>
The <code>--sup</code> option is required. It ensures that the generated application has a supervision tree, which is required by Ecto.
</p>

<div class="note">
<p>
It's OK to run <code>mix new</code> without <code>--sup</code> option. But, you need to do more works later.
</p>

</div>
</div>
</div>

<div id="outline-container-org0228804" class="outline-3">
<h3 id="org0228804"><span class="section-number-3">5.2</span> <a href="#org0228804">Adding dependencies</a></h3>
<div class="outline-text-3" id="text-5-2">
<p>
Two packages are required:
</p>
<ul class="org-ul">
<li><code>ecto_sql</code></li>
<li><code>postgrex</code> - database driver for PostgreSQL</li>
</ul>

<p>
Edit <code>mix.exs</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defp</span> <span class="org-function-name">deps</span> <span class="org-keyword">do</span>
  [
    {<span class="org-elixir-atom">:ecto_sql</span>, <span class="org-string">"~&gt; 3.0"</span>},
    {<span class="org-elixir-atom">:postgrex</span>, <span class="org-string">"&gt;= 0.0.0"</span>}
  ]
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Fetch dependencies:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix deps.get
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba8d64d" class="outline-3">
<h3 id="orgba8d64d"><span class="section-number-3">5.3</span> <a href="#orgba8d64d">Creating a Repo</a></h3>
<div class="outline-text-3" id="text-5-3">
<blockquote>
<p>
You may be wondering what a Repo is. Now, just think it as a normal Elixir module. We will explain it later.
</p>
</blockquote>

<p>
Edit <code>lib/paper/repo.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Repo</span>,
    <span class="org-elixir-atom">otp_app:</span> <span class="org-elixir-atom">:paper</span>,
    <span class="org-elixir-atom">adapter:</span> <span class="org-type">Ecto.Adapters.Postgres</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
About the options:
</p>
<ul class="org-ul">
<li><code>:otp_app</code> option indicates the location of Ecto configuration.</li>
<li><code>:adapter</code> option indicates the database adapter.</li>
</ul>

<div class="note">
<p>
You can name <code>Paper.Repo</code> as whatever you want, but <code>Repo</code> is prefered in convention.
</p>

</div>
</div>
</div>

<div id="outline-container-org0722567" class="outline-3">
<h3 id="org0722567"><span class="section-number-3">5.4</span> <a href="#org0722567">Adding Repo to supervision tree</a></h3>
<div class="outline-text-3" id="text-5-4">
<p>
Edit <code>lib/paper/application.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Application</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">See https://hexdocs.pm/elixir/Application.html</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">for more information on OTP Applications</span>
  <span class="org-elixir-attribute">@moduledoc</span> <span class="org-elixir-atom">false</span>

  <span class="org-keyword">use</span> <span class="org-type">Application</span>

  <span class="org-keyword">def</span> <span class="org-function-name">start</span>(<span class="org-comment">_type</span>, <span class="org-comment">_args</span>) <span class="org-keyword">do</span>
    <span class="org-variable-name">children</span> = [
      <span class="org-comment-delimiter"># </span><span class="org-comment">add repo to supervision tree</span>
      {<span class="org-type">Paper.Repo</span>, []}
    ]

    <span class="org-comment-delimiter"># </span><span class="org-comment">See https://hexdocs.pm/elixir/Supervisor.html</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">for other strategies and supported options</span>
    <span class="org-variable-name">opts</span> = [<span class="org-elixir-atom">strategy:</span> <span class="org-elixir-atom">:one_for_one</span>, <span class="org-elixir-atom">name:</span> <span class="org-type">Paper.Supervisor</span>]
    <span class="org-type">Supervisor</span>.start_link(children, opts)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org33b92f4" class="outline-3">
<h3 id="org33b92f4"><span class="section-number-3">5.5</span> <a href="#org33b92f4">Adding configurations</a></h3>
<div class="outline-text-3" id="text-5-5">
<p>
Edit <code>config/config.exs</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">import</span> <span class="org-type">Config</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">make Ecto related Mix tasks work as expected.</span>
config <span class="org-elixir-atom">:paper</span>,
  <span class="org-elixir-atom">ecto_repos:</span> [<span class="org-type">Paper.Repo</span>]

<span class="org-comment-delimiter"># </span><span class="org-comment">add configurations for connecting database.</span>
config <span class="org-elixir-atom">:paper</span>, <span class="org-type">Paper.Repo</span>,
  <span class="org-elixir-atom">database:</span> <span class="org-string">"paper_repo"</span>,
  <span class="org-elixir-atom">username:</span> <span class="org-string">"postgres"</span>,
  <span class="org-elixir-atom">password:</span> <span class="org-string">"postgres"</span>,
  <span class="org-elixir-atom">hostname:</span> <span class="org-string">"localhost"</span>
</pre>
</div>

<div class="note">
<p>
Make sure the username and password specified in config file match yours.
</p>

</div>
</div>
</div>

<div id="outline-container-orgb5b2588" class="outline-3">
<h3 id="orgb5b2588"><span class="section-number-3">5.6</span> <a href="#orgb5b2588">Creating database</a></h3>
<div class="outline-text-3" id="text-5-6">
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.create
The database for Paper.Repo has been created
</pre>
</div>
</div>
</div>

<div id="outline-container-org4091eae" class="outline-3">
<h3 id="org4091eae"><span class="section-number-3">5.7</span> <a href="#org4091eae">(optional) Updating configurations for <code>mix format</code></a></h3>
<div class="outline-text-3" id="text-5-7">
<p>
Ecto has additional formatting rules. In order to apply these rules, following content should be added.
</p>

<p>
Edit <code>.formatter.exs</code> for formatting general Elixir code:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-comment-delimiter"># </span><span class="org-comment">Used by "mix format"</span>
[
  <span class="org-elixir-atom">import_deps:</span> [<span class="org-elixir-atom">:ecto</span>],
  <span class="org-elixir-atom">inputs:</span> [<span class="org-string">"*.{ex,exs}"</span>, <span class="org-string">"{config,lib,test}/**/*.{ex,exs}"</span>, <span class="org-string">"priv/*/seeds.exs"</span>],
  <span class="org-elixir-atom">subdirectories:</span> [<span class="org-string">"priv/*/migrations"</span>]
]
</pre>
</div>

<p>
Edit <code>priv/repo/migrations/.formatter.exs</code> for formatting migrations:
</p>
<div class="org-src-container">
<pre class="src src-elixir">[
  <span class="org-elixir-atom">import_deps:</span> [<span class="org-elixir-atom">:ecto_sql</span>],
  <span class="org-elixir-atom">inputs:</span> [<span class="org-string">"*.exs"</span>]
]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb461df" class="outline-3">
<h3 id="orgbb461df"><span class="section-number-3">5.8</span> <a href="#orgbb461df">Last</a></h3>
<div class="outline-text-3" id="text-5-8">
<p>
Now, Ecto is ready to communicate with the database.
</p>
</div>
</div>
</div>

<div id="outline-container-org55f791f" class="outline-2">
<h2 id="sample-data-model"><span class="section-number-2">6</span> <a href="#sample-data-model">Sample Data Model</a></h2>
<div class="outline-text-2" id="text-sample-data-model">
<p>
Before writing any code, we should design a data model first.
</p>

<p>
Our data model contains 5 tables:
</p>
<ul class="org-ul">
<li>authors</li>
<li>posts</li>
<li>tags</li>
<li>permalinks</li>
<li>comments</li>
</ul>

<p>
Their relationships are described in following figure:
</p>

<figure>
<img src="./assets/4ba08274293d7631377890af10bf767a.png" alt="4ba08274293d7631377890af10bf767a.png">

<figcaption><span class="figure-number">Figure 1: </span>Entity Relationship Diagram</figcaption>
</figure>

<div class="note">
<p>
The one-to-one relationship between posts and permalinks isn't necessary for most case, it's preserved for demonstration only.
</p>

</div>
</div>
</div>

<div id="outline-container-orgc637e3f" class="outline-2">
<h2 id="orgc637e3f"><span class="section-number-2">7</span> <a href="#orgc637e3f">The Structure Of Ecto</a></h2>
<div class="outline-text-2" id="text-7">
<blockquote>
<p>
Ecto's real purpose is translating Elixir concepts into a database language, which is SQL in most cases.
</p>

<p>
&#x2013; Programming Phoenix
</p>
</blockquote>

<p>
Before talking about Ecto in details, we will introduce the structure of Ecto first. It let us have an overview of Ecto.
</p>

<p>
Ecto includes 6 main modules which are separated in 2 packages:
</p>

<p>
<code>ecto</code> package - contains the core functionalities:
</p>
<ul class="org-ul">
<li><code>Repo</code> handles all the communications between Ecto and data store.</li>
<li><code>Query</code> provides DSL for querying.</li>
<li><code>Schema</code> provides DSL for mapping data source to Elixir structs.</li>
<li><code>Changeset</code> provides functions for handling changes.</li>
<li><code>Multi</code> controls transactions in a clean way.</li>
</ul>

<p>
<code>ecto_sql</code> package - provides SQL-based adapters and database migrations:
</p>
<ul class="org-ul">
<li>database-specified adapters, such as PostgreSQL, MySQL.</li>
<li><code>Migration</code> provides DSL for tracking database changes in a clean way.</li>
</ul>

<div class="question">
<p>
Why we just add <code>ecto_sql</code> when adding dependencies?
</p>

<p>
Because <code>ecto</code> is the dependency of <code>ecto_sql</code>, it's OK to add <code>ecto_sql</code> alone.
</p>

</div>

<div class="note">
<p>
When talking about <code>Schema</code>, we are not saying database, but data source. That is because <code>Schema</code> can be used to map any data source to Elixir structs, not just database tables.
</p>

</div>

<p>
We have already known the structure of Ecto. Next, we will introduce them separately.
</p>
</div>
</div>

<div id="outline-container-org5a88c7e" class="outline-2">
<h2 id="org5a88c7e"><span class="section-number-2">8</span> <a href="#org5a88c7e"><code>Ecto.Migration</code></a></h2>
<div class="outline-text-2" id="text-8">
<p>
<code>Ecto.Migration</code> helps developers to track database changes in a clean way.
</p>
</div>

<div id="outline-container-org1f3f0d6" class="outline-3">
<h3 id="org1f3f0d6"><span class="section-number-3">8.1</span> <a href="#org1f3f0d6">What is a migration?</a></h3>
<div class="outline-text-3" id="text-8-1">
<p>
A migration is a file includes a set of instructions which changes database structure.
</p>
</div>
</div>

<div id="outline-container-org6b19ddf" class="outline-3">
<h3 id="org6b19ddf"><span class="section-number-3">8.2</span> <a href="#org6b19ddf">Generating template for migrations</a></h3>
<div class="outline-text-3" id="text-8-2">
<p>
The default directory for storing migrations is <code>priv/repo/migrations</code>. We can create migration file in that directory manually.
</p>

<p>
But,  Ecto provides a Mix task for generating a migration, let's use it:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.gen.migration &lt;migration name&gt;
</pre>
</div>

<p>
After executing above command, a new migration file containing a module with empty <code>change</code> function will be generated.
</p>
</div>
</div>

<div id="outline-container-orgce65bd5" class="outline-3">
<h3 id="creating-migrations"><span class="section-number-3">8.3</span> <a href="#creating-migrations">Creating migrations</a></h3>
<div class="outline-text-3" id="text-creating-migrations">
<p>
In relational database, there are 3 types of relationships:
</p>
<ul class="org-ul">
<li>on-to-one (1-1)</li>
<li>one-to-many (1-N)</li>
<li>many-to-many (N-N)</li>
</ul>

<p>
As we saw in <a href="#sample-data-model">Sample Data Model</a>, we have four relationships, and they cover all types of relationships:
</p>
<ul class="org-ul">
<li>the relationship between posts and permalinks is one-to-one.</li>
<li>the relationship between posts and comments is one-to-many.</li>
<li>the relationship between posts and tags is many-to-many.</li>
<li>the relationship between authors and posts is one-to-many.</li>
</ul>

<p>
Next, we will take the sample data model as an example, and demonstrate how to create migrations for all of these relationships.
</p>

<div class="note">
<p>
When creating a migration, we generally define following things:
</p>
<ol class="org-ol">
<li>table names</li>
<li>columns</li>
<li>relationships</li>
<li>indexes</li>
</ol>

</div>
</div>

<div id="outline-container-org7c2a4f5" class="outline-4">
<h4 id="org7c2a4f5"><span class="section-number-4">8.3.1</span> <a href="#org7c2a4f5">build relationship between posts and permalinks (1-1)</a></h4>
<div class="outline-text-4" id="text-8-3-1">
<p>
As we said above:
</p>
<ul class="org-ul">
<li>one post has one permalink.</li>
<li>one permalink belongs to one post.</li>
</ul>

<p>
Generate a migration file:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.gen.migration assoc_posts_permalinks
</pre>
</div>

<p>
Edit the generated migration file:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo.Migrations.AssocPostsPermalinks</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Migration</span>

  <span class="org-keyword">def</span> <span class="org-function-name">change</span> <span class="org-keyword">do</span>
    create table(<span class="org-string">"posts"</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:title</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:body</span>, <span class="org-elixir-atom">:text</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>

      timestamps()
    <span class="org-keyword">end</span>

    create table(<span class="org-string">"permalinks"</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:post_id</span>, references(<span class="org-string">"posts"</span>), <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:url</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>

      timestamps()
    <span class="org-keyword">end</span>

    create unique_index(<span class="org-string">"permalinks"</span>, [<span class="org-elixir-atom">:post_id</span>])
    create unique_index(<span class="org-string">"permalinks"</span>, [<span class="org-elixir-atom">:url</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Apply the new migration:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.migrate
</pre>
</div>
</div>
</div>

<div id="outline-container-org3b1bbda" class="outline-4">
<h4 id="org3b1bbda"><span class="section-number-4">8.3.2</span> <a href="#org3b1bbda">build relationship between posts and comments (1-N)</a></h4>
<div class="outline-text-4" id="text-8-3-2">
<p>
As we said above:
</p>
<ul class="org-ul">
<li>one post has many comments.</li>
<li>one comment belongs to one post.</li>
</ul>

<p>
Generate a migration file:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.gen.migration assoc_posts_comments
</pre>
</div>

<p>
Edit the generated migration file:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo.Migrations.AssocPostsComments</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Migration</span>

  <span class="org-keyword">def</span> <span class="org-function-name">change</span> <span class="org-keyword">do</span>
    create table(<span class="org-string">"comments"</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:post_id</span>, references(<span class="org-string">"posts"</span>), <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:nickname</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:email</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:body</span>, <span class="org-elixir-atom">:text</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>

      timestamps()
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Apply the new migration:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.migrate
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc2bbac6" class="outline-4">
<h4 id="orgc2bbac6"><span class="section-number-4">8.3.3</span> <a href="#orgc2bbac6">build relationship between posts and tags (N-N)</a></h4>
<div class="outline-text-4" id="text-8-3-3">
<p>
As we said above:
</p>
<ul class="org-ul">
<li>one post has many tags.</li>
<li>one tag has many posts.</li>
</ul>

<p>
Generate a migration file:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.gen.migration assoc_posts_tags
</pre>
</div>

<p>
Edit the generated migration file:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo.Migrations.AssocPostsTags</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Migration</span>

  <span class="org-keyword">def</span> <span class="org-function-name">change</span> <span class="org-keyword">do</span>
    create table(<span class="org-string">"posts"</span>) <span class="org-keyword">do</span>
    <span class="org-keyword">end</span>

    create table(<span class="org-string">"tags"</span>) <span class="org-keyword">do</span>
    <span class="org-keyword">end</span>

    create table(<span class="org-string">"posts_tags"</span>, <span class="org-elixir-atom">primary_key:</span> <span class="org-elixir-atom">false</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:post_id</span>, references(<span class="org-string">"posts"</span>), <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:tag_id</span>, references(<span class="org-string">"tags"</span>), <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
    <span class="org-keyword">end</span>

    create unique_index(<span class="org-string">"posts_tags"</span>, [<span class="org-elixir-atom">:post_id</span>, <span class="org-elixir-atom">:tag_id</span>])
    create index(<span class="org-string">"posts_tags"</span>, [<span class="org-elixir-atom">:post_id</span>])
    create index(<span class="org-string">"posts_tags"</span>, [<span class="org-elixir-atom">:tag_id</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Apply the new migration:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.migrate
</pre>
</div>
</div>
</div>

<div id="outline-container-org4184b3f" class="outline-4">
<h4 id="org4184b3f"><span class="section-number-4">8.3.4</span> <a href="#org4184b3f">build relation ship between authors and posts (1-N)</a></h4>
<div class="outline-text-4" id="text-8-3-4">
<p>
As we said above:
</p>
<ul class="org-ul">
<li>one author has many posts.</li>
<li>one post belongs to one author.</li>
</ul>

<p>
Generate a migration file:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.gen.migration assoc_authors_posts
</pre>
</div>

<p>
Edit the generated migration file:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo.Migrations.AssocAuthorsPosts</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Migration</span>

  <span class="org-keyword">def</span> <span class="org-function-name">change</span> <span class="org-keyword">do</span>
    create table(<span class="org-string">"authors"</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
      add <span class="org-elixir-atom">:bio</span>, <span class="org-elixir-atom">:string</span>, <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>

      timestamps()
    <span class="org-keyword">end</span>

    alter table(<span class="org-string">"posts"</span>) <span class="org-keyword">do</span>
      add <span class="org-elixir-atom">:author_id</span>, references(<span class="org-string">"authors"</span>), <span class="org-elixir-atom">null:</span> <span class="org-elixir-atom">false</span>
    <span class="org-keyword">end</span>

    create unique_index(<span class="org-string">"authors"</span>, [<span class="org-elixir-atom">:name</span>])
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Apply the new migration:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.migrate
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org7fc57a8" class="outline-3">
<h3 id="org7fc57a8"><span class="section-number-3">8.4</span> <a href="#org7fc57a8">Applying migrations</a></h3>
<div class="outline-text-3" id="text-8-4">
<p>
We have introduced how to apply migration in above section. Read more details at:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix help ecto.migrate
</pre>
</div>
</div>
</div>

<div id="outline-container-org99b441d" class="outline-3">
<h3 id="org99b441d"><span class="section-number-3">8.5</span> <a href="#org99b441d">Rolling back migrations</a></h3>
<div class="outline-text-3" id="text-8-5">
<div class="org-src-container">
<pre class="src src-sh">$ mix ecto.rollback
</pre>
</div>

<p>
Read more details at:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ mix help ecto.rollback
</pre>
</div>
</div>
</div>

<div id="outline-container-org4eef55b" class="outline-3">
<h3 id="org4eef55b"><span class="section-number-3">8.6</span> <a href="#org4eef55b">Available column types</a></h3>
<div class="outline-text-3" id="text-8-6">
<p>
When <a href="#creating-migrations">creating migrations</a>, we have specified some column types, such as <code>:string</code> or <code>:text</code>.
</p>

<p>
<code>text</code> is a valid SQL data type, but <code>string</code> not. So, what is that?
</p>

<p>
Ecto maps primitive types to the appropriate database column types by the database adapters. Such as:
</p>
<ul class="org-ul">
<li>map <code>:string</code> to <code>:varchar</code></li>
<li>map <code>:binary</code> to <code>:bytea</code> or <code>:blob</code>.</li>
<li>&#x2026;</li>
</ul>

<div class="note">
<p>
Ecto defines the mapping at <code>ecto_sql</code> package. For PostgreSQL, the details can be found <a href="https://github.com/elixir-ecto/ecto_sql/blob/eda193965ef112cd0e8f584c58a2efa751655a3e/lib/ecto/adapters/postgres/connection.ex#L1181">here</a>.
</p>

</div>

<p>
Besides, column types supported by database can be used directly in migration. Such as:
</p>
<ul class="org-ul">
<li><code>:char</code></li>
<li><code>:varchar</code></li>
<li><code>:text</code></li>
<li>&#x2026;</li>
</ul>

<p>
And, column types with database-specific options can be used, too. Such as:
</p>
<ul class="org-ul">
<li><code>:"int unsigned"</code></li>
<li><code>:"time without time zone"</code></li>
<li>&#x2026;</li>
</ul>
</div>
</div>

<div id="outline-container-org8220ed7" class="outline-3">
<h3 id="org8220ed7"><span class="section-number-3">8.7</span> <a href="#org8220ed7">Adding index</a></h3>
<div class="outline-text-3" id="text-8-7">
<p>
Read more details at <code>h Ecto.Migration.index</code>.
</p>
</div>
</div>

<div id="outline-container-orge49d442" class="outline-3">
<h3 id="the-options-of-references"><span class="section-number-3">8.8</span> <a href="#the-options-of-references">The options of <code>references</code></a></h3>
<div class="outline-text-3" id="text-the-options-of-references">
<p>
<code>Ecto.Migration.references</code> have two options which should be explained here - <code>:on_delete</code> and <code>:on_update</code>.
</p>

<p>
The official docs don't talk much about them. But, we can know the details by reading <a href="https://github.com/elixir-ecto/ecto_sql/blob/2ec71d74655cc076b6c965740a357dfe1505883a/lib/ecto/adapters/postgres/connection.ex#L1043">related source code</a> and <a href="https://www.postgresql.org/docs/12/ddl-constraints.html#DDL-CONSTRAINTS-FK">corresponding docs of PostgreSQL</a>.
</p>
</div>

<div id="outline-container-org4c981fb" class="outline-4">
<h4 id="org4c981fb"><span class="section-number-4">8.8.1</span> <a href="#org4c981fb">the <code>:on_delete</code> option</a></h4>
<div class="outline-text-4" id="text-8-8-1">
<p>
The <code>:on_delete</code> option specifies the behavior of referencing rows when a referenced row is deleted. Following is the available values.
</p>

<dl class="org-dl">
<dt><code>:delete_all</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON DELETE CASCADE</code></li>
<li>description: The referencing rows will be deleted.</li>
</ul></dd>

<dt><code>:nilify_all</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON DELETE SET NULL</code></li>
<li>description: The foreign key of referencing rows will be set as <code>NULL</code>.</li>
</ul></dd>

<dt><code>:restrict</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON DELETE RESTRICT</code></li>
<li>description: Prevent deletion of a referenced row.</li>
</ul></dd>

<dt><code>:nothing</code> (default behavior)</dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>NO ACTION</code></li>
<li>description: Do nothing. (It will cause an error when checking constrains.)</li>
</ul></dd>
</dl>
</div>
</div>

<div id="outline-container-org2fe481b" class="outline-4">
<h4 id="org2fe481b"><span class="section-number-4">8.8.2</span> <a href="#org2fe481b">the <code>:on_update</code> option</a></h4>
<div class="outline-text-4" id="text-8-8-2">
<div class="note">
<p>
This option isn't used frequently.
</p>

</div>

<p>
The <code>:on_update</code> option specifies the behavior of referencing rows when the column of a referenced rows is updated. Following is the available values.
</p>

<dl class="org-dl">
<dt><code>:update_all</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON UPDATE CASCADE</code></li>
<li>description: The foreign key of referencing rows will be updated according to the referenced rows.</li>
</ul></dd>

<dt><code>:nilify_all</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON UPDATE SET NULL</code></li>
<li>description: The foreign key of referencing rows will be set as <code>NULL</code>.</li>
</ul></dd>

<dt><code>:restrict</code></dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>ON UPDATE RESTRICT</code></li>
<li>description: Prevent update of a referenced row.</li>
</ul></dd>

<dt><code>:nothing</code> (default behavior)</dt><dd><ul class="org-ul">
<li>PostgreSQL clause: <code>NO ACTION</code></li>
<li>description: Do nothing. (It will cause an error when checking constrains.)</li>
</ul></dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-orga7180ea" class="outline-3">
<h3 id="orga7180ea"><span class="section-number-3">8.9</span> <a href="#orga7180ea">Practices</a></h3>
<div class="outline-text-3" id="text-8-9">
</div>
<div id="outline-container-orgc4d62fa" class="outline-4">
<h4 id="orgc4d62fa"><span class="section-number-4">8.9.1</span> <a href="#orgc4d62fa">ensure migrations can be rolled back</a></h4>
<div class="outline-text-4" id="text-8-9-1">
<p>
When adding a new migration, we should ensure that we can roll them back.
</p>

<p>
Generally, Ecto can infer the rollback behavior of <code>change/0</code> function in the migrations. When it can't, consider using <code>up/0</code> and <code>down/0</code>.
</p>
</div>
</div>

<div id="outline-container-org99d70c3" class="outline-4">
<h4 id="org99d70c3"><span class="section-number-4">8.9.2</span> <a href="#org99d70c3">should I editing an existing migration?</a></h4>
<div class="outline-text-4" id="text-8-9-2">
<p>
If the migration hasn't been commited to VCS, you are free to edit an existing one.
</p>

<p>
If the migration has been committed and you are not the only one in the team, you'd better creating a new one.
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa5fe85" class="outline-3">
<h3 id="orgaa5fe85"><span class="section-number-3">8.10</span> <a href="#orgaa5fe85">Last</a></h3>
<div class="outline-text-3" id="text-8-10">
<p>
The database is ready, it's time to insert data into it.
</p>
</div>
</div>
</div>

<div id="outline-container-org9d8c5e4" class="outline-2">
<h2 id="org9d8c5e4"><span class="section-number-2">9</span> <a href="#org9d8c5e4"><code>Ecto.Repo</code></a></h2>
<div class="outline-text-2" id="text-9">
<p>
<code>Ecto.Repo</code> provides basic API for communicating with database.
</p>
</div>

<div id="outline-container-orgc75a026" class="outline-3">
<h3 id="orgc75a026"><span class="section-number-3">9.1</span> <a href="#orgc75a026">The Repository Pattern</a></h3>
<div class="outline-text-3" id="text-9-1">
<p>
Ecto adopts <b><b>The Repository Pattern</b></b> for accessing underlying data store. In this pattern, there's a role called Repository who controls all the communications between Ecto and data store.
</p>

<p>
The general lifecyle of queries looks like:
</p>
<ol class="org-ol">
<li>All the queries are submitted to the Repository.</li>
<li>The Repository transforms the queries and send them to data store.</li>
<li>The Repository handles the responses from data store and transforms them into easy-to-use way.</li>
</ol>

<p>
The keypoint is <b><b>the Repository acts as a gateway of data store</b></b>. When you want to make changes to data store, talk to Repository.
</p>
</div>
</div>

<div id="outline-container-orga7786eb" class="outline-3">
<h3 id="orga7786eb"><span class="section-number-3">9.2</span> <a href="#orga7786eb">Repository in Ecto</a></h3>
<div class="outline-text-3" id="text-9-2">
<p>
<code>Ecto.Repo</code> is the so-called <i>Repository</i> in Ecto.
</p>

<p>
But, <code>Ecto.Repo</code> isn't used directly. It should be used in a self-created module. When creating the sample application, we have created the module called <code>Paper.Repo</code>.
</p>

<div class="note">
<p>
For brevity, in the following sections, I will use <code>Repo</code> to represent the self-created module - <code>Paper.Repo</code>, and use <code>Ecto.Repo</code> to represent the original module.
</p>

</div>
</div>
</div>

<div id="outline-container-orgedbd1a7" class="outline-3">
<h3 id="orgedbd1a7"><span class="section-number-3">9.3</span> <a href="#orgedbd1a7">Low level API for CRUD</a></h3>
<div class="outline-text-3" id="text-9-3">
<p>
<code>Repo</code> provides low level API to complete CRUD operations directly.
</p>

<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Operation Name</th>
<th scope="col" class="org-left">Function Name</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">CREATE</td>
<td class="org-left"><code>Repo.insert_all</code></td>
</tr>

<tr>
<td class="org-left">READ</td>
<td class="org-left"><code>Repo.query</code> (an alias for <code>Ecto.Adapters.SQL.query/4</code>)</td>
</tr>

<tr>
<td class="org-left">UPDATE</td>
<td class="org-left"><code>Repo.update_all</code></td>
</tr>

<tr>
<td class="org-left">DELETE</td>
<td class="org-left"><code>Repo.delete_all</code></td>
</tr>
</tbody>
</table>

<p>
All <code>*_all</code> functions support <code>:returning</code> option for selecting which fields to return. Read their documents for more details.
</p>

<div class="note">
<p>
When using <code>Repo.query</code>. you will find the return value is hard to parse. And, working with SQL directly is clumsy and unsafe (SQL injection).
</p>

<p>
<code>Ecto.Query</code> is the better choice for queries.
</p>

</div>
</div>
</div>

<div id="outline-container-org26dc889" class="outline-3">
<h3 id="org26dc889"><span class="section-number-3">9.4</span> <a href="#org26dc889">Extending Repo</a></h3>
<div class="outline-text-3" id="text-9-4">
<p>
<code>Repo</code> is a regular Elixir module, we can extend it as normal. It is useful when we want to:
</p>
<ul class="org-ul">
<li>encapsulate tediously long options for particular functions.</li>
<li>add functions that Ecto doesn't support currently.</li>
<li>&#x2026;</li>
</ul>

<p>
For example, adding a counting function:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Repo</span>,
    <span class="org-elixir-atom">otp_app:</span> <span class="org-elixir-atom">:paper</span>,
    <span class="org-elixir-atom">adapter:</span> <span class="org-type">Ecto.Adapters.Postgres</span>

  <span class="org-keyword">def</span> <span class="org-function-name">count</span>(table) <span class="org-keyword">do</span>
    aggregate(table, <span class="org-elixir-atom">:count</span>, <span class="org-elixir-atom">:id</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Call the added function:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Paper.Repo</span>.count(<span class="org-string">"authors"</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-org297f0fe" class="outline-3">
<h3 id="org297f0fe"><span class="section-number-3">9.5</span> <a href="#org297f0fe">Last</a></h3>
<div class="outline-text-3" id="text-9-5">
<p>
Read more details at <code>h Ecto.Repo</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org409fe4a" class="outline-2">
<h2 id="org409fe4a"><span class="section-number-2">10</span> <a href="#org409fe4a"><code>Ecto.Schema</code></a></h2>
<div class="outline-text-2" id="text-10">
<p>
<code>Ecto.Schema</code> provides DSL for mapping data source to Elixir structs.
</p>
</div>

<div id="outline-container-org6c49d1d" class="outline-3">
<h3 id="org6c49d1d"><span class="section-number-3">10.1</span> <a href="#org6c49d1d">Creating schemas</a></h3>
<div class="outline-text-3" id="text-10-1">
<div class="note">
<p>
Like creating a migration, when creating a schema, we generally define following things:
</p>
<ol class="org-ol">
<li>table names</li>
<li>fields</li>
<li>associations (relationships)</li>
</ol>

</div>
</div>

<div id="outline-container-org8f39c0d" class="outline-4">
<h4 id="org8f39c0d"><span class="section-number-4">10.1.1</span> <a href="#org8f39c0d">creating a context first</a></h4>
<div class="outline-text-4" id="text-10-1-1">
<p>
A context is a concept introduced by Phoenix. It is a dedicated module that expose and group related functionality.
</p>

<p>
Here, we will just create a context without talking much about it. If you are interested in the details of contexts, please read <a href="https://hexdocs.pm/phoenix/contexts.html">the official docs</a>.
</p>

<p>
Our context will be named as <code>CMS</code>. Now, let's create it by editing <code>lib/paper/cms.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS</span> <span class="org-keyword">do</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
So far, the context is empty, because we have no public API for this context. That's OK.
</p>
</div>
</div>

<div id="outline-container-org2d7096a" class="outline-4">
<h4 id="org2d7096a"><span class="section-number-4">10.1.2</span> <a href="#org2d7096a">tips about associations</a></h4>
<div class="outline-text-4" id="text-10-1-2">
<p>
<code>Ecto.Schema</code> provides following macros for indicating the associations between schemas:
</p>
<ul class="org-ul">
<li>one-to-one - <code>has_one</code> / <code>belongs_to</code></li>
<li>one-to-many - <code>has_many</code> / <code>belongs_to</code></li>
<li>many-to-many - <code>many_to_many</code> with <code>:join_through</code> option</li>
</ul>

<p>
It's hard to understand them without any example. Next, we will create necessary schemas step by step. When you have questions about them, please read respective documents like <code>h Ecto.Schema.many_to_many</code>.
</p>
</div>
</div>

<div id="outline-container-org3e8e9b1" class="outline-4">
<h4 id="org3e8e9b1"><span class="section-number-4">10.1.3</span> <a href="#org3e8e9b1">creating a schema for permalinks</a></h4>
<div class="outline-text-4" id="text-10-1-3">
<p>
Edit <code>lib/paper/cms/permalink.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Permalink</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Post</span>

  schema <span class="org-string">"permalinks"</span> <span class="org-keyword">do</span>
    belongs_to <span class="org-elixir-atom">:post</span>, <span class="org-type">Post</span>
    field <span class="org-elixir-atom">:url</span>, <span class="org-elixir-atom">:string</span>

    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<div class="note">
<p>
<code>schema</code> and <code>field</code> do two things:
</p>
<ol class="org-ol">
<li>define the mapping between schema and database.</li>
<li>define a struct for current schema.</li>
</ol>

</div>
</div>
</div>

<div id="outline-container-org7084b8f" class="outline-4">
<h4 id="org7084b8f"><span class="section-number-4">10.1.4</span> <a href="#org7084b8f">creating a schema for comments</a></h4>
<div class="outline-text-4" id="text-10-1-4">
<p>
Edit <code>lib/paper/cms/comment.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Comment</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Post</span>

  schema <span class="org-string">"comments"</span> <span class="org-keyword">do</span>
    belongs_to <span class="org-elixir-atom">:post</span>, <span class="org-type">Post</span>
    field <span class="org-elixir-atom">:nickname</span>, <span class="org-elixir-atom">:string</span>
    field <span class="org-elixir-atom">:email</span>, <span class="org-elixir-atom">:string</span>
    field <span class="org-elixir-atom">:body</span>, <span class="org-elixir-atom">:string</span>

    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org271e0b8" class="outline-4">
<h4 id="org271e0b8"><span class="section-number-4">10.1.5</span> <a href="#org271e0b8">creating a schema for tags</a></h4>
<div class="outline-text-4" id="text-10-1-5">
<p>
Edit <code>lib/paper/cms/tag.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Tag</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Post</span>

  schema <span class="org-string">"tags"</span> <span class="org-keyword">do</span>
    many_to_many <span class="org-elixir-atom">:posts</span>, <span class="org-type">Post</span>, <span class="org-elixir-atom">join_through:</span> <span class="org-string">"posts_tags"</span>
    field <span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:string</span>

    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ed262a" class="outline-4">
<h4 id="org7ed262a"><span class="section-number-4">10.1.6</span> <a href="#org7ed262a">creating a schema for posts</a></h4>
<div class="outline-text-4" id="text-10-1-6">
<p>
Edit <code>lib/paper/cms/post.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Post</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Permalink</span>
  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Comment</span>
  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Tag</span>

  schema <span class="org-string">"posts"</span> <span class="org-keyword">do</span>
    field <span class="org-elixir-atom">:title</span>, <span class="org-elixir-atom">:string</span>
    field <span class="org-elixir-atom">:body</span>, <span class="org-elixir-atom">:string</span>

    has_one <span class="org-elixir-atom">:permalink</span>, <span class="org-type">Permalink</span>
    has_many <span class="org-elixir-atom">:comments</span>, <span class="org-type">Comment</span>
    many_to_many <span class="org-elixir-atom">:tags</span>, <span class="org-type">Tag</span>, <span class="org-elixir-atom">join_through:</span> <span class="org-string">"posts_tags"</span>

    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgea032a2" class="outline-4">
<h4 id="orgea032a2"><span class="section-number-4">10.1.7</span> <a href="#orgea032a2">creating a schema for authors</a></h4>
<div class="outline-text-4" id="text-10-1-7">
<p>
Edit <code>lib/paper/cms/author.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Author</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Post</span>

  schema <span class="org-string">"authors"</span> <span class="org-keyword">do</span>
    field <span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:string</span>
    field <span class="org-elixir-atom">:bio</span>, <span class="org-elixir-atom">:string</span>
    has_many <span class="org-elixir-atom">:posts</span>, <span class="org-type">Post</span>

    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Edit <code>lib/paper/cms/post.ex</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Post</span> <span class="org-keyword">do</span>
  <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

  <span class="org-keyword">alias</span> <span class="org-type">Paper.CMS.Author</span>

  schema <span class="org-string">"posts"</span> <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

    belongs_to <span class="org-elixir-atom">:author</span>, <span class="org-type">Author</span>

    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org70ecb23" class="outline-4">
<h4 id="org70ecb23"><span class="section-number-4">10.1.8</span> <a href="#org70ecb23">available field types</a></h4>
<div class="outline-text-4" id="text-10-1-8">
<dl class="org-dl">
<dt>built-in types</dt><dd>Read more details at <b>Primative types</b> section in <code>h Ecto.Schema</code>.</dd>

<dt>custom types</dt><dd>Read more details at <b>Custom types</b> section in <code>h Ecto.Schema</code>.</dd>
</dl>
</div>
</div>
</div>

<div id="outline-container-org29c76d1" class="outline-3">
<h3 id="org29c76d1"><span class="section-number-3">10.2</span> <a href="#org29c76d1">Starting IEx</a></h3>
<div class="outline-text-3" id="text-10-2">
<p>
We have created all required schemas, it is time to do some experiments with them.
</p>

<p>
Before starting IEx, it is better to add configurations for it. The configurations help us type less.
</p>

<p>
Edit <code>.iex.exs</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">import</span> <span class="org-type">Ecto.Query</span>

<span class="org-keyword">alias</span> <span class="org-type">Paper.Repo</span>
<span class="org-keyword">alias</span> <span class="org-type">Paper.CMS</span>.{<span class="org-type">Permalink</span>, <span class="org-type">Tag</span>, <span class="org-type">Comment</span>, <span class="org-type">Post</span>, <span class="org-type">Author</span>}
</pre>
</div>

<p>
Now, let's start it:
</p>
<div class="org-src-container">
<pre class="src src-sh">$ iex -S mix
</pre>
</div>
</div>
</div>

<div id="outline-container-org931fe6e" class="outline-3">
<h3 id="org931fe6e"><span class="section-number-3">10.3</span> <a href="#org931fe6e">CRUD</a></h3>
<div class="outline-text-3" id="text-10-3">
</div>
<div id="outline-container-org6652e70" class="outline-4">
<h4 id="org6652e70"><span class="section-number-4">10.3.1</span> <a href="#org6652e70">insert</a></h4>
<div class="outline-text-4" id="text-10-3-1">
<p>
Ecto provides following functions which can be used with schemas:
</p>
<ul class="org-ul">
<li><code>Repo.insert</code></li>
<li><code>Repo.insert!</code></li>
<li><code>Repo.insert_all</code></li>
<li><code>Repo.insert_or_update</code></li>
<li><code>Repo.insert_or_update!</code></li>
</ul>
</div>

<div id="outline-container-orga6e9af9" class="outline-5">
<h5 id="orga6e9af9"><span class="section-number-5">10.3.1.1</span> <a href="#orga6e9af9">inserting without association</a></h5>
<div class="outline-text-5" id="text-10-3-1-1">
<p>
Authors and tags can be inserted without associations:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-comment-delimiter"># </span><span class="org-comment">insert authors</span>
<span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">"I have a cool name!"</span>}  |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Julia"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">"I have a beautiful name!"</span>}  |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">Repo</span>.count(<span class="org-string">"authors"</span>) <span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; 2</span>

<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Life"</span>} |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Art"</span>} |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Religion"</span>} |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">Repo</span>.count(<span class="org-string">"tags"</span>) <span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; 3</span>
</pre>
</div>

<p>
But, there's a problem here - the data is NOT validated before inserting to database. This means we can insert anything we want. Try to insert a piece of useless data:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">""</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">""</span>}  |&gt; <span class="org-type">Repo</span>.insert()
</pre>
</div>

<p>
Obviously, above useless data is not what we want. If you want to validate the data before inserting to database, <code>Ecto.Changeset</code> which will be introduced later is needed.
</p>
</div>
</div>

<div id="outline-container-org7233ccf" class="outline-5">
<h5 id="org7233ccf"><span class="section-number-5">10.3.1.2</span> <a href="#org7233ccf">inserting with associations</a></h5>
<div class="outline-text-5" id="text-10-3-1-2">
<p>
Inserting with associations needs <code>Ecto.Changeset</code> which will be introduced later.
</p>
</div>
</div>
</div>

<div id="outline-container-org580ddc6" class="outline-4">
<h4 id="org580ddc6"><span class="section-number-4">10.3.2</span> <a href="#org580ddc6">query</a></h4>
<div class="outline-text-4" id="text-10-3-2">
<p>
Ecto provides following functions which can be used with schemas:
</p>
<ul class="org-ul">
<li><code>Repo.all</code></li>
<li><code>Repo.one</code></li>
<li><code>Repo.one!</code></li>
<li><code>Repo.get</code></li>
<li><code>Repo.get!</code></li>
<li><code>Repo.get_by</code></li>
<li><code>Repo.get_by!</code></li>
<li>&#x2026;</li>
</ul>

<p>
Query the data we have inserted to database:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Repo</span>.all(<span class="org-type">Author</span>)
<span class="org-type">Repo</span>.get(<span class="org-type">Author</span>, 2)
<span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, %{<span class="org-elixir-atom">name:</span> <span class="org-string">"Julia"</span>})
<span class="org-comment-delimiter"># </span><span class="org-comment">...</span>
</pre>
</div>

<p>
If you need build complex query, try to use <code>Ecto.Query</code> which will be introduced later.
</p>
</div>
</div>

<div id="outline-container-orgdb349fd" class="outline-4">
<h4 id="orgdb349fd"><span class="section-number-4">10.3.3</span> <a href="#orgdb349fd">update</a></h4>
<div class="outline-text-4" id="text-10-3-3">
<p>
Ecto provides following functions which can be used with schemas:
</p>
<ul class="org-ul">
<li><code>Repo.update</code></li>
<li><code>Repo.update!</code></li>
<li><code>Repo.update_all</code></li>
</ul>

<p>
Updating needs <code>Ecto.Changeset</code> which will be introduced later.
</p>
</div>
</div>

<div id="outline-container-org753b086" class="outline-4">
<h4 id="org753b086"><span class="section-number-4">10.3.4</span> <a href="#org753b086">delete</a></h4>
<div class="outline-text-4" id="text-10-3-4">
<p>
Ecto provides following functions which can be used with schemas:
</p>
<ul class="org-ul">
<li><code>Repo.delete</code></li>
<li><code>Repo.delete!</code></li>
<li><code>Repo.delete_all</code></li>
</ul>

<p>
Delete one author:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, %{<span class="org-elixir-atom">name:</span> <span class="org-string">""</span>})

<span class="org-keyword">case</span> <span class="org-type">Repo</span>.delete(author) <span class="org-keyword">do</span>
  {<span class="org-elixir-atom">:ok</span>, <span class="org-comment">_author</span>} -&gt;
    <span class="org-string">"Deleted successfully."</span>
  {<span class="org-elixir-atom">:error</span>, <span class="org-comment">_changeset</span>} -&gt;
    <span class="org-string">"Something went wrong."</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga35a01b" class="outline-3">
<h3 id="orga35a01b"><span class="section-number-3">10.4</span> <a href="#orga35a01b">Last</a></h3>
<div class="outline-text-3" id="text-10-4">
<p>
As you see, without <code>Ecto.Changeset</code>, we can't insert or update data reliably.
</p>

<p>
Next, we will introduce <code>Ecto.Changeset</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc0adbf0" class="outline-2">
<h2 id="orgc0adbf0"><span class="section-number-2">11</span> <a href="#orgc0adbf0"><code>Ecto.Changeset</code></a></h2>
<div class="outline-text-2" id="text-11">
<p>
<code>Ecto.Changeset</code> encapsulates the whole change policy, including allowed fields, detecting changes and validations. It helps us to make changes to database safely.
</p>
</div>

<div id="outline-container-org119f58f" class="outline-3">
<h3 id="org119f58f"><span class="section-number-3">11.1</span> <a href="#org119f58f">About <code>%Ecto.Changeset{}</code></a></h3>
<div class="outline-text-3" id="text-11-1">
<p>
<code>%Ecto.Changeset{}</code> is the struct holding all the changes will be performed to the database.
</p>

<p>
For brevity, in the following sections, I will use <code>%Changeset{}</code> instead of <code>%Ecto.Changeset{}</code>.
</p>
</div>
</div>

<div id="outline-container-org4c7b9c8" class="outline-3">
<h3 id="org4c7b9c8"><span class="section-number-3">11.2</span> <a href="#org4c7b9c8">Basics</a></h3>
<div class="outline-text-3" id="text-11-2">
<p>
<code>Ecto.Changeset</code> breaks the update process into 3 stages:
</p>
<ol class="org-ol">
<li>casting and filtering raw data into changes</li>
<li>validating changes</li>
<li>sending changes to database</li>
</ol>

<div class="org-src-container">
<pre class="src src-elixir">raw_data
|&gt; cast_and_filter
|&gt; validate_changes
|&gt; send_changes_to_database
</pre>
</div>

<p>
Next, we will talk about each step in detail.
</p>
</div>
</div>

<div id="outline-container-org1611e12" class="outline-3">
<h3 id="org1611e12"><span class="section-number-3">11.3</span> <a href="#org1611e12">Casting and Filtering</a></h3>
<div class="outline-text-3" id="text-11-3">
<p>
The first step is casting and filtering the raw data, and transform it as <code>%Changeset{}</code>. In Ecto:
</p>
<ul class="org-ul">
<li><i>casting</i> means type conversion, like converting string to integer.</li>
<li><i>filtering</i> means filtering unused data out.</li>
</ul>

<p>
Depending on where the data is coming from, this step can be done in two different ways.
</p>
</div>

<div id="outline-container-org95f1ad9" class="outline-4">
<h4 id="org95f1ad9"><span class="section-number-4">11.3.1</span> <a href="#org95f1ad9">handling internal data</a></h4>
<div class="outline-text-4" id="text-11-3-1">
<blockquote>
<p>
Internal data is the data which is coming from application code.
</p>
</blockquote>

<p>
Handling internal data can be done with <code>Ecto.Changeset.change</code>.
</p>

<p>
Create a new changeset from a new schema:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">import</span> <span class="org-type">Ecto.Changeset</span>

<span class="org-variable-name">changeset</span> = change(<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Music"</span>})
</pre>
</div>

<p>
Create a changeset from an existing schema:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">import</span> <span class="org-type">Ecto.Changeset</span>

<span class="org-variable-name">author</span> = <span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"unknown"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">""</span>}  |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-variable-name">changeset</span> = change(author)

<span class="org-comment-delimiter"># </span><span class="org-comment">add data when calling change function</span>
<span class="org-variable-name">changeset</span> = change(author, <span class="org-elixir-atom">name:</span> <span class="org-string">"Vicious"</span>)
<span class="org-variable-name">changeset</span> = change(author, <span class="org-elixir-atom">name:</span> <span class="org-string">"Vicious"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">"I have an evil name!"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">change function can be called multiple times</span>
<span class="org-variable-name">changeset</span> = author
|&gt; change(<span class="org-elixir-atom">name:</span> <span class="org-string">"Vicious"</span>)
|&gt; change(<span class="org-elixir-atom">bio:</span> <span class="org-string">"I have a evil name!"</span>)
</pre>
</div>

<p>
Read more details at <code>h Ecto.Changeset.change</code>.
</p>
</div>
</div>

<div id="outline-container-org9d11705" class="outline-4">
<h4 id="org9d11705"><span class="section-number-4">11.3.2</span> <a href="#org9d11705">handling external data</a></h4>
<div class="outline-text-4" id="text-11-3-2">
<blockquote>
<p>
External data is the data which is coming outside of your application code, such as:
</p>
<ul class="org-ul">
<li>user forms</li>
<li>API calls</li>
<li>command line</li>
<li>CSV file</li>
<li>&#x2026;</li>
</ul>
</blockquote>

<p>
When working with external data, we should suppose that the data is dirty, then, <b>cast</b> and <b>filter</b> them.
</p>

<p>
Handling external data can be done with <code>Ecto.Changeset.cast</code>.
</p>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">params</span> = %{
<span class="org-string">"name"</span> =&gt; <span class="org-string">"Vicious"</span>,
<span class="org-string">"bio"</span> =&gt; <span class="org-string">"I have an evil name!"</span>,
<span class="org-string">"true_words"</span> =&gt; <span class="org-string">"I want to be a good man."</span>
}

<span class="org-variable-name">changeset</span> = cast(<span class="org-type">%Author</span>{}, params, [<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:bio</span>])
</pre>
</div>

<p>
Read more details at <code>h Ecto.Changeset.cast</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org1e53527" class="outline-3">
<h3 id="org1e53527"><span class="section-number-3">11.4</span> <a href="#org1e53527">Validating</a></h3>
<div class="outline-text-3" id="text-11-4">
<p>
After casting and filtering, we have a <code>%Changeset{}</code> which represents changes. Before sending it to database, we should also validate the changes.
</p>

<p>
Ecto provides two kinds of utilities for validating. They perform similar functions, but differ in implementation:
</p>
<ul class="org-ul">
<li>validations</li>
<li>constraints</li>
</ul>
</div>

<div id="outline-container-org62b6acf" class="outline-4">
<h4 id="org62b6acf"><span class="section-number-4">11.4.1</span> <a href="#org62b6acf">validations</a></h4>
<div class="outline-text-4" id="text-11-4-1">
<p>
Validations are functions provided by <code>Ecto.Changeset</code>. They accept a changeset, return a changeset.
</p>
</div>

<div id="outline-container-orgc6a0b01" class="outline-5">
<h5 id="orgc6a0b01"><span class="section-number-5">11.4.1.1</span> <a href="#orgc6a0b01">built-in validations</a></h5>
<div class="outline-text-5" id="text-11-4-1-1">
<p>
Built-in validations are in form of <code>Ecto.Changeset.validate_*</code>.
</p>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">params</span> = %{
  <span class="org-string">"name"</span> =&gt; <span class="org-string">"x"</span>
}

<span class="org-variable-name">changeset</span> =
  <span class="org-type">%Author</span>{}
  |&gt; cast(params, [<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:bio</span>])
  |&gt; validate_required([<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:bio</span>])
  |&gt; validate_length(<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">min:</span> 3)

changset.valid? <span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; false</span>
</pre>
</div>

<p>
When passing all the validations, <code>changeset.valid?</code> will be <code>true</code>. Or, <code>changeset.valid?</code> will be <code>false</code>, and the details of validation error can be found at <code>changeset.errors</code>.
</p>
</div>
</div>

<div id="outline-container-org358ed1c" class="outline-5">
<h5 id="org358ed1c"><span class="section-number-5">11.4.1.2</span> <a href="#org358ed1c">custom validations</a></h5>
<div class="outline-text-5" id="text-11-4-1-2">
<p>
Ecto provides support for custom validations in case that you need validtions which are not supported by it.
</p>

<p>
Read more details at <code>h Ecto.Changeset.validate_change</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org5a1fcb9" class="outline-4">
<h4 id="org5a1fcb9"><span class="section-number-4">11.4.2</span> <a href="#org5a1fcb9">constraints</a></h4>
<div class="outline-text-4" id="text-11-4-2">
<p>
Like validations, contraints are functions provided by <code>Ecto.Changeset</code>, too. It allows developers to use underlying relational database features to maintain database integrity. Such as, preventing duplicated username in a user management system.
</p>

<p>
They accept a changeset, return a changeset, just like validations.
</p>

<p>
When using a constraint, you need:
</p>
<ol class="org-ol">
<li>define database constraints</li>
<li>catch constraint errors</li>
</ol>

<p>
Next, we will introduce these 2 steps with <code>unique_constraint/3</code>.
</p>

<div class="note">
<p>
Unlike validations, constraints won't run before hitting database. Instead, they run when Ecto accepts constraint errors returned from database.
</p>

</div>
</div>

<div id="outline-container-org6a8c133" class="outline-5">
<h5 id="org6a8c133"><span class="section-number-5">11.4.2.1</span> <a href="#org6a8c133">defining database constraints</a></h5>
<div class="outline-text-5" id="text-11-4-2-1">
<p>
Constraints are enforced by database. Because of that, they should be defined in database level.
</p>

<p>
In order to manage database constraints, it is better to create them by using migrations. Just like we did when <a href="#creating-migrations">creating migrations</a>.
</p>
<div class="org-src-container">
<pre class="src src-elixir">create unique_index(<span class="org-elixir-atom">:authors</span>, [<span class="org-elixir-atom">:name</span>])
</pre>
</div>
</div>
</div>

<div id="outline-container-org39b7408" class="outline-5">
<h5 id="org39b7408"><span class="section-number-5">11.4.2.2</span> <a href="#org39b7408">catching constraint errors</a></h5>
<div class="outline-text-5" id="text-11-4-2-2">
<p>
If a constraint error isn't catched, it will be raised as <code>Ecto.ConstraintError</code>.
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-comment-delimiter"># </span><span class="org-comment">create two authors with the same name, which will raise a constraint error.</span>
<span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">""</span>} |&gt; <span class="org-type">Repo</span>.insert()
<span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">""</span>} |&gt; <span class="org-type">Repo</span>.insert()

<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt;</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">(Ecto.ConstraintError) constraint error when attempting to insert struct:</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">- authors_name_index (unique_constraint)</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">If you would like to stop this constraint violation from raising an</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">exception and instead add it as an error to your changeset, please</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">call `unique_constraint/3` on your changeset with the constraint</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">`:name` as an option.</span>
<span class="org-comment-delimiter">#</span>
<span class="org-comment-delimiter"># </span><span class="org-comment">The changeset has not defined any constraint.</span>
</pre>
</div>

<p>
In order to catch it, an <code>Ecto.Changeset.*_constraint</code>-like function should be used:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>, <span class="org-elixir-atom">bio:</span> <span class="org-string">""</span>}
|&gt; change()
|&gt; unique_constraint(<span class="org-elixir-atom">:name</span>)
|&gt; <span class="org-type">Repo</span>.insert()

<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; {:error, changeset}</span>
</pre>
</div>

<p>
As you can see,  <code>Ecto.ConstraintError</code> is catched and transformed as an error in changeset.
</p>
</div>
</div>
</div>

<div id="outline-container-org82312f2" class="outline-4">
<h4 id="org82312f2"><span class="section-number-4">11.4.3</span> <a href="#org82312f2">execution rules of validations and constraints</a></h4>
<div class="outline-text-4" id="text-11-4-3">
<ol class="org-ol">
<li>execute all of valiations in order:
<ol class="org-ol">
<li>if succeed to execute one validation, execute next validation.</li>
<li>if failed to execute one validation, execute next validation, too. But, all of constraints will not be executed any more.</li>
</ol></li>
<li>execute all of constraints in order:
<ol class="org-ol">
<li>if succeed to execute one constraint, execute another constraint.</li>
<li>if failed to execute one constraint, the rest of constraints will not be executed any more.</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgdd012e3" class="outline-4">
<h4 id="orgdd012e3"><span class="section-number-4">11.4.4</span> <a href="#orgdd012e3">mixins</a></h4>
<div class="outline-text-4" id="text-11-4-4">
<p>
Mixins are functions mix the features of validations and constraints. They have following features:
</p>
<ul class="org-ul">
<li>their execution rules are same as validations.</li>
<li>they communicates with database to validating values.</li>
</ul>

<div class="note">
<p>
Mixin is not a terminology in Ecto. I name them in this way, personally.
</p>

</div>
</div>

<div id="outline-container-org3c0d69f" class="outline-5">
<h5 id="org3c0d69f"><span class="section-number-5">11.4.4.1</span> <a href="#org3c0d69f"><code>Ecto.Changeset.unsafe_validate_unique</code></a></h5>
<div class="outline-text-5" id="text-11-4-4-1">
<p>
Read details at <code>h Ecto.Changeset.unsafe_validate_unique</code>.
</p>

<p>
<code>Ecto.Changeset.unsafe_validate_unique</code> isn't a replacement of <code>Ecto.Changeset.unique_constraint</code>. It just used for providing a early feedback for users. Generally, it is used in this way:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">%Author</span>{}
|&gt; cast(params, [<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">:bio</span>])
|&gt; validate_required(<span class="org-elixir-atom">:name</span>)
|&gt; unsafe_validate_unique(<span class="org-elixir-atom">:name</span>, <span class="org-type">Repo</span>)
|&gt; validate_length(<span class="org-elixir-atom">:name</span>, <span class="org-elixir-atom">min:</span> 3)
|&gt; unique_constraint(<span class="org-elixir-atom">:name</span>)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org97b5e1b" class="outline-4">
<h4 id="org97b5e1b"><span class="section-number-4">11.4.5</span> <a href="#org97b5e1b">rendering errors</a></h4>
<div class="outline-text-4" id="text-11-4-5">
<p>
Ecto doesn't provide solutions for rendering <code>changeset.errors</code>. When you need to render them, consider using <code>Ecto.Changeset.traverse_errors</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org67061b9" class="outline-3">
<h3 id="org67061b9"><span class="section-number-3">11.5</span> <a href="#org67061b9">Send Changes to database</a></h3>
<div class="outline-text-3" id="text-11-5">
<p>
Last step, send <code>%Changeset{}</code> to database with functions provided by <code>Repo</code>, such as <code>Repo.insert</code>, <code>Repo.update</code>, etc.
</p>
</div>
</div>

<div id="outline-container-orgf19b711" class="outline-3">
<h3 id="orgf19b711"><span class="section-number-3">11.6</span> <a href="#orgf19b711">Last</a></h3>
<div class="outline-text-3" id="text-11-6">
<p>
Read more details at <code>Ecto.Changeset</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgc4eb9c0" class="outline-2">
<h2 id="orgc4eb9c0"><span class="section-number-2">12</span> <a href="#orgc4eb9c0"><code>Ecto.Query</code></a></h2>
<div class="outline-text-2" id="text-12">
<p>
<code>Ecto.Query</code> provides DSL for querying. It makes querying simple and elegant.
</p>
</div>

<div id="outline-container-org536b7d6" class="outline-3">
<h3 id="org536b7d6"><span class="section-number-3">12.1</span> <a href="#org536b7d6">Syntax</a></h3>
<div class="outline-text-3" id="text-12-1">
<p>
There are two types of syntax when using <code>Ecto.Query</code>:
</p>
<ul class="org-ul">
<li>keyword syntax</li>
<li>expression syntax</li>
</ul>

<p>
Following SQL will be wrote into above two types of syntax:
</p>
<div class="org-src-container">
<pre class="src src-sql"><span class="org-keyword">SELECT</span> a.<span class="org-keyword">name</span>, a.bio <span class="org-keyword">FROM</span> authors <span class="org-keyword">AS</span> a
</pre>
</div>
</div>

<div id="outline-container-org2dc3728" class="outline-4">
<h4 id="org2dc3728"><span class="section-number-4">12.1.1</span> <a href="#org2dc3728">keyword syntax</a></h4>
<div class="outline-text-4" id="text-12-1-1">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">select:</span> [a.name, a.bio]

<span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>

<div id="outline-container-orga57723c" class="outline-4">
<h4 id="orga57723c"><span class="section-number-4">12.1.2</span> <a href="#orga57723c">expression syntax</a></h4>
<div class="outline-text-4" id="text-12-1-2">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = <span class="org-string">"authors"</span> |&gt; select([a], [a.name, a.bio])

<span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf5041e5" class="outline-4">
<h4 id="orgf5041e5"><span class="section-number-4">12.1.3</span> <a href="#orgf5041e5">How to choose syntax?</a></h4>
<div class="outline-text-4" id="text-12-1-3">
<blockquote>
<p>
The syntax you choose depends on your taste and the problems you're solving:
</p>
<ul class="org-ul">
<li>keyword syntax: convenient for pulling together ad-hoc queries and solving one-off problems.</li>
<li>expression syntax: better for building an application's unique complex layered query API.</li>
</ul>

<p>
Each syntax has its advantages.
</p>

<p>
&#x2013; Programming Phoenix
</p>
</blockquote>

<p>
Personally, I think the keyword syntax is more convinient to write. Because of that, following queries will be wrote in Keyword Syntax.
</p>
</div>
</div>
</div>

<div id="outline-container-org78a6ba8" class="outline-3">
<h3 id="org78a6ba8"><span class="section-number-3">12.2</span> <a href="#org78a6ba8">Basic usage</a></h3>
<div class="outline-text-3" id="text-12-2">
<p>
A query is created and used in following steps:
</p>
<ol class="org-ol">
<li>creating a query</li>
<li>committing a query</li>
</ol>
</div>

<div id="outline-container-org705ec6a" class="outline-4">
<h4 id="org705ec6a"><span class="section-number-4">12.2.1</span> <a href="#org705ec6a">creating a query</a></h4>
<div class="outline-text-4" id="text-12-2-1">
<p>
When creating a query, you can use a table name string or a schema. All of them have implemented <code>Ecto.Queryable</code> protocol.
</p>

<p>
Use a table name string:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.id == 2, <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]
</pre>
</div>

<div class="note">
<p>
If not using a schema when building a query, the <code>:select</code> option is required. Or, Ecto will raise an error.
</p>

</div>

<p>
Use a schema:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-type">Author</span>, <span class="org-elixir-atom">where:</span> a.id == 2
</pre>
</div>
</div>
</div>

<div id="outline-container-orgba23020" class="outline-4">
<h4 id="orgba23020"><span class="section-number-4">12.2.2</span> <a href="#orgba23020">committing a query</a></h4>
<div class="outline-text-4" id="text-12-2-2">
<p>
Use <code>Repo.all</code> or <code>Repo.one</code> for committing a query:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf377eae" class="outline-3">
<h3 id="orgf377eae"><span class="section-number-3">12.3</span> <a href="#orgf377eae">Debugging</a></h3>
<div class="outline-text-3" id="text-12-3">
<p>
<code>Ecto.Adapters.SQL.to_sql/3</code> is used for translating a query to corresponding SQL statement. We can use these functions to help us inspect the details of queries.
</p>

<p>
For example:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.id == 2, <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]

<span class="org-type">Ecto.Adapters.SQL</span>.to_sql(<span class="org-elixir-atom">:all</span>, <span class="org-type">Repo</span>, query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; {"SELECT a0.\"name\" FROM \"authors\" AS a0 WHERE (a0.\"id\" = 2)", []}</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">equal to</span>
<span class="org-type">Repo</span>.to_sql(<span class="org-elixir-atom">:all</span>, query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; {"SELECT a0.\"name\" FROM \"authors\" AS a0 WHERE (a0.\"id\" = 2)", []}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org9ffdbf1" class="outline-3">
<h3 id="org9ffdbf1"><span class="section-number-3">12.4</span> <a href="#org9ffdbf1">Dynamic values</a></h3>
<div class="outline-text-3" id="text-12-4">
</div>
<div id="outline-container-org712ef77" class="outline-4">
<h4 id="org712ef77"><span class="section-number-4">12.4.1</span> <a href="#org712ef77">pin operator</a></h4>
<div class="outline-text-4" id="text-12-4-1">
<p>
In Ecto, <code>^</code> (pin operator) is used for marking values or expressions that need interpolation in an Ecto query.
</p>

<div class="note">
<p>
<code>^</code> is named as caret in English.
</p>

</div>

<p>
When <code>Ecto.Query</code> is converted into a SQL statement, values and expressions marked by ^ will become parameterized values.
</p>

<div class="note">
<p>
Parameterized values provides protection against SQL-injection attacks.
</p>

</div>

<p>
An example:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author_name</span> = <span class="org-string">"Spike"</span>
<span class="org-variable-name">query</span> = from <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">name:</span> ^author_name], <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:id</span>, <span class="org-elixir-atom">:name</span>]
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; SELECT a0."id", a0."name" FROM "authors" AS a0 WHERE (a0."name" = $1) ["Spike"]</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org7894eed" class="outline-4">
<h4 id="org7894eed"><span class="section-number-4">12.4.2</span> <a href="#org7894eed">type conversion</a></h4>
<div class="outline-text-4" id="text-12-4-2">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author_id</span> = 2
<span class="org-variable-name">query</span> = from <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">id:</span> ^author_id], <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; [%{name: "Spike"}]&#8203;</span>

<span class="org-variable-name">author_id</span> = <span class="org-string">"2"</span>
<span class="org-variable-name">query</span> = from <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">id:</span> ^author_id], <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; Type Error, you have to make type conversion manually.</span>

<span class="org-variable-name">artist_id</span> = <span class="org-string">"2"</span>
<span class="org-variable-name">query</span> = from <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">id:</span> type(^author_id, <span class="org-elixir-atom">:integer</span>)], <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; [%{name: "Spike"}]&#8203;</span>
</pre>
</div>

<div class="note">
<p>
<code>type</code> function is defined in <code>Ecto.Query.API</code>.
</p>

</div>

<p>
Now, type conversion seems tedious. But, after using Schema, the conversion will be done automatically.
</p>
</div>
</div>
</div>

<div id="outline-container-org94dcae8" class="outline-3">
<h3 id="org94dcae8"><span class="section-number-3">12.5</span> <a href="#org94dcae8">Query bindings</a></h3>
<div class="outline-text-3" id="text-12-5">
<p>
A query binding is a variable referring to the table of the query. You can treat it as table alias in SQL.
</p>

<p>
There are two types of bindings:
</p>
<ul class="org-ul">
<li>positional bindings</li>
<li>named bindings</li>
</ul>

<p>
Read more details at <b>Composition</b> section in <code>h Ecto.Query</code>.
</p>
</div>

<div id="outline-container-org0a62163" class="outline-4">
<h4 id="org0a62163"><span class="section-number-4">12.5.1</span> <a href="#org0a62163">which one should I use?</a></h4>
<div class="outline-text-4" id="text-12-5-1">
<p>
When a query is small, using positional bindings would be fine.
</p>

<p>
But, when a query is large and contains joins across several tables, using positional bindings would make tracking bindings difficult. Therefore, named bindings is preferred.
</p>
</div>
</div>
</div>

<div id="outline-container-org2e18714" class="outline-3">
<h3 id="org2e18714"><span class="section-number-3">12.6</span> <a href="#org2e18714">Query API</a></h3>
<div class="outline-text-3" id="text-12-6">
<p>
Query API provides functions can be used in a query.
</p>

<p>
Read <code>h Ecto.Query.API</code> for a complete list of all available API.
</p>
</div>
</div>

<div id="outline-container-org796ecfe" class="outline-3">
<h3 id="org796ecfe"><span class="section-number-3">12.7</span> <a href="#org796ecfe">Raw SQL</a></h3>
<div class="outline-text-3" id="text-12-7">
<blockquote>
<p>
Best abstractions offer escape hatch.
</p>

<p>
&#x2013; Programming Phoenix
</p>
</blockquote>

<p>
Ecto can't represent all possible queries with its own syntax, so it provides two backup plans:
</p>
<ol class="org-ol">
<li><code>Ecto.Query.API.fragment/1</code>: generate a SQL fragment which can be inserted into a Ecto query.</li>
<li><code>Repo.query</code> / <code>Repo.query!</code>: run a raw SQL with parameterized values.</li>
</ol>

<p>
Read more details in their docs.
</p>

<div class="note">
<p>
Although <code>Ecto.Query.API.fragment/1</code> is a function provided by <code>h Ecto.Query.API</code>, but I still put it in this section because of their correlation.
</p>

</div>
</div>
</div>

<div id="outline-container-org1e3beb2" class="outline-3">
<h3 id="org1e3beb2"><span class="section-number-3">12.8</span> <a href="#org1e3beb2">Filtering with <code>where</code></a></h3>
<div class="outline-text-3" id="text-12-8">
<p>
<code>Ecto.Query</code> provides two macros for filtering:
</p>
<ul class="org-ul">
<li><code>where</code></li>
<li><code>or_where</code></li>
</ul>
</div>
</div>

<div id="outline-container-orgb931eee" class="outline-3">
<h3 id="orgb931eee"><span class="section-number-3">12.9</span> <a href="#orgb931eee">Combining results with unions</a></h3>
<div class="outline-text-3" id="text-12-9">
<p>
When using unions, the two queries need to have result sets with the same column names and data type.
</p>

<p>
Supported unions:
</p>
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">macro name</th>
<th scope="col" class="org-left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>union</code></td>
<td class="org-left">remove duplicated items.</td>
</tr>

<tr>
<td class="org-left"><code>union_all</code></td>
<td class="org-left">don't remove duplicated items, faster.</td>
</tr>

<tr>
<td class="org-left"><code>intersect</code></td>
<td class="org-left">remove duplicated items.</td>
</tr>

<tr>
<td class="org-left"><code>intersect_all</code></td>
<td class="org-left">don't remove duplicated items, faster.</td>
</tr>

<tr>
<td class="org-left"><code>except</code></td>
<td class="org-left">remove duplicated items.</td>
</tr>

<tr>
<td class="org-left"><code>except_all</code></td>
<td class="org-left">don't remove duplicated items, faster.</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orge140c4d" class="outline-3">
<h3 id="orge140c4d"><span class="section-number-3">12.10</span> <a href="#orge140c4d">Ordering with <code>order_by</code></a></h3>
<div class="outline-text-3" id="text-12-10">
<p>
Read more details at <code>h Ecto.Query.order_by</code>.
</p>

<p>
When sorting rows by multiple columns specified by <code>order_by</code>, the records will grouped and sorted by first column, then by the second column, and so on.
</p>

<p>
When ordering, you should also notice <code>NULL</code> value. Some databases put them first, others put them last. If you want to control the order explicitly, try following options:
</p>
<ul class="org-ul">
<li><code>:asc_nulls_last</code></li>
<li><code>:asc_nulls_first</code></li>
<li><code>:desc_nulls_last</code></li>
<li><code>:desc_nulls_first</code></li>
</ul>
</div>
</div>

<div id="outline-container-org5fc1496" class="outline-3">
<h3 id="org5fc1496"><span class="section-number-3">12.11</span> <a href="#org5fc1496">Grouping with <code>group_by</code></a></h3>
<div class="outline-text-3" id="text-12-11">
<p>
When you want to filtering rows after grouping, you should use <code>having</code> and <code>or_having</code>, rather than <code>where</code> and <code>or_where</code>.
</p>

<p>
Read more details at <code>h Ecto.Query.group_by</code>.
</p>
</div>
</div>

<div id="outline-container-org25f77eb" class="outline-3">
<h3 id="org25f77eb"><span class="section-number-3">12.12</span> <a href="#org25f77eb">Joins</a></h3>
<div class="outline-text-3" id="text-12-12">
<p>
Joins are required when query acroess multiple tables at once.
</p>

<p>
Read more details at <code>h Ecto.Query.join</code>.
</p>
</div>
</div>

<div id="outline-container-orgdd0e001" class="outline-3">
<h3 id="orgdd0e001"><span class="section-number-3">12.13</span> <a href="#orgdd0e001">Composable Queries</a></h3>
<div class="outline-text-3" id="text-12-13">
<p>
Ecto queries are composable. This feature can help us to break large queries into small reusable queries. Small queries are easy to read and maintain, which is good for us.
</p>

<div class="note">
<p>
The small reusable queries are composed into a query via <code>Ecto.Queryable</code> protocol.
</p>

</div>

<p>
Read more details at <b>Composition</b> section in <code>h Ecto.Query</code>.
</p>
</div>
</div>

<div id="outline-container-orgeeca1dd" class="outline-3">
<h3 id="orgeeca1dd"><span class="section-number-3">12.14</span> <a href="#orgeeca1dd">Using a schema</a></h3>
<div class="outline-text-3" id="text-12-14">
<p>
As you see, we are using table name string in above queries. But, with a schema, we can get better experiences, because it contains:
</p>
<ul class="org-ul">
<li>the type info of fields, type conversion can be done automatically.</li>
<li>the list of fields, <code>:select</code> option isn't necessary when querying.</li>
</ul>

<p>
Give it an example. Without a schema=, we have to do type conversion and specify the <code>:select</code> manually:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author_id</span> = <span class="org-string">"2"</span>
<span class="org-variable-name">query</span> = from <span class="org-string">"authors"</span>,
  <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">id:</span> type(^author_id, <span class="org-elixir-atom">:integer</span>)],
  <span class="org-elixir-atom">select:</span> [<span class="org-elixir-atom">:name</span>]

<span class="org-type">Repo</span>.all(query)
</pre>
</div>

<p>
With a schema, query can be simpler:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author_id</span> = <span class="org-string">"2"</span>
<span class="org-variable-name">query</span> = from <span class="org-type">Author</span>, <span class="org-elixir-atom">where:</span> [<span class="org-elixir-atom">id:</span> ^author_id]

<span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge9b2712" class="outline-3">
<h3 id="orge9b2712"><span class="section-number-3">12.15</span> <a href="#orge9b2712">Tips</a></h3>
<div class="outline-text-3" id="text-12-15">
</div>
<div id="outline-container-orgeb0f0e3" class="outline-4">
<h4 id="orgeb0f0e3"><span class="section-number-4">12.15.1</span> <a href="#orgeb0f0e3">specifying data structure with <code>:select</code> option</a></h4>
<div class="outline-text-4" id="text-12-15-1">
<p>
<code>:select</code> option is not only for specifying the fields returned, but also the data structure returned.
</p>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.id == 2, <span class="org-elixir-atom">select:</span> [a.name]
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; [["Spike"]]</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.id == 2, <span class="org-elixir-atom">select:</span> %{<span class="org-elixir-atom">name:</span> a.name}
<span class="org-type">Repo</span>.all(query)
<span class="org-comment-delimiter">#</span><span class="org-comment">=&gt; [%{name: "Spike"}]</span>
</pre>
</div>

<p>
The output become a list of map now.
</p>
</div>
</div>

<div id="outline-container-orgacf61a2" class="outline-4">
<h4 id="orgacf61a2"><span class="section-number-4">12.15.2</span> <a href="#orgacf61a2">other ways to use queries</a></h4>
<div class="outline-text-4" id="text-12-15-2">
<p>
Besides reading data, queries can be used with <code>Repo.*_all</code> functions for updating or deleting data.
</p>

<div class="org-src-container">
<pre class="src src-elixir">from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.bio == <span class="org-string">""</span>
|&gt; <span class="org-type">Repo</span>.update_all(<span class="org-elixir-atom">set:</span> [<span class="org-elixir-atom">bio:</span> <span class="org-string">"Hello World!"</span>])

from a <span class="org-keyword">in</span> <span class="org-string">"authors"</span>, <span class="org-elixir-atom">where:</span> a.bio == <span class="org-string">"Hello World!"</span>
|&gt; <span class="org-type">Repo</span>.delete_all()
</pre>
</div>

<p>
By using queries in this way, we can update or delete data precisely.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd8c50e4" class="outline-3">
<h3 id="orgd8c50e4"><span class="section-number-3">12.16</span> <a href="#orgd8c50e4">Last</a></h3>
<div class="outline-text-3" id="text-12-16">
<p>
Read more at <code>h Ecto.Query</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-orgdaf96ed" class="outline-2">
<h2 id="orgdaf96ed"><span class="section-number-2">13</span> <a href="#orgdaf96ed">Associations</a></h2>
<div class="outline-text-2" id="text-13">
<blockquote>
<p>
Relational Database Management System like PostgreSQL does a lot of works to help developers define and enforce the relationships between tables.
</p>

<p>
Instead of treating the database as dumb storage, Ecto uses the strengths of the database to help keeping the data consistent.
</p>

<p>
&#x2013; Programming Phoenix
</p>
</blockquote>

<p>
So far, we have talked about data without associations. Now, let's introduce data with associations.
</p>

<p>
In this chapter, I will use the associtaion between authors and posts as the example:
</p>
<ul class="org-ul">
<li>one author has many posts.</li>
<li>one post belongs to one author.</li>
</ul>

<p>
And, records in <b>authors</b> table is called as parent records, and records in <b>posts</b> table is called as children records.
</p>
</div>

<div id="outline-container-org3867564" class="outline-3">
<h3 id="org3867564"><span class="section-number-3">13.1</span> <a href="#org3867564">Insert / Update</a></h3>
<div class="outline-text-3" id="text-13-1">
<p>
When inserting or updating records, there's two questions should be answered first:
</p>
<ol class="org-ol">
<li>what is the type of records? parent or child?</li>
<li>If the type is child, how many children records do you want to insert or update?</li>
</ol>
</div>

<div id="outline-container-org741a3b6" class="outline-4">
<h4 id="org741a3b6"><span class="section-number-4">13.1.1</span> <a href="#org741a3b6">insert / update a parent record</a></h4>
<div class="outline-text-4" id="text-13-1-1">
<p>
Just insert or update it, nothing to say.
</p>
</div>
</div>

<div id="outline-container-org6495058" class="outline-4">
<h4 id="org6495058"><span class="section-number-4">13.1.2</span> <a href="#org6495058">insert a child record</a></h4>
<div class="outline-text-4" id="text-13-1-2">
<p>
When inserting a child record, <code>Ecto.build_assoc</code> is a great choice. You pass it a parent record and the name of association. It returns a new generated child record with the foreign key setting to the parent record:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>)

<span class="org-comment-delimiter"># </span><span class="org-comment">bulid a new child record without filling fields</span>
<span class="org-type">Ecto</span>.build_assoc(author, <span class="org-elixir-atom">:posts</span>)
|&gt; <span class="org-type">Repo</span>.insert!()

<span class="org-comment-delimiter"># </span><span class="org-comment">bulid a new child record with filling fields</span>
<span class="org-type">Ecto</span>.build_assoc(author, <span class="org-elixir-atom">:posts</span>, <span class="org-elixir-atom">title:</span> <span class="org-string">"Hello World!"</span>, <span class="org-elixir-atom">body:</span> <span class="org-string">""</span>)
|&gt; <span class="org-type">Repo</span>.insert!()

<span class="org-comment-delimiter"># </span><span class="org-comment">bulid a new child record with filling fields by change()</span>
<span class="org-type">Ecto</span>.build_assoc(author, <span class="org-elixir-atom">:posts</span>)
|&gt; change(%{<span class="org-elixir-atom">title:</span> <span class="org-string">"Hello World"</span>, <span class="org-elixir-atom">body:</span> <span class="org-string">""</span>})
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
Use <code>Ecto.Changeset.put_assoc</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>)

<span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"Hello world"</span>, <span class="org-elixir-atom">body:</span> <span class="org-string">""</span>}
|&gt; change()
|&gt; put_assoc(<span class="org-elixir-atom">:author</span>, author)
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
We can also set <code>author_id</code> field directly.
</p>

<p>
Use struct:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>)

<span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"Hello world"</span>, <span class="org-elixir-atom">body:</span> <span class="org-string">""</span>, <span class="org-elixir-atom">author_id:</span> author.id}
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
Use <code>Ecto.Changeset.put_change</code>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>)

<span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"Hello world"</span>, <span class="org-elixir-atom">body:</span> <span class="org-string">""</span>}
|&gt; change()
|&gt; put_change(<span class="org-elixir-atom">:author_id</span>, author.id)
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>
</div>
</div>

<div id="outline-container-org5654781" class="outline-4">
<h4 id="org5654781"><span class="section-number-4">13.1.3</span> <a href="#org5654781">update a child record</a></h4>
<div class="outline-text-4" id="text-13-1-3">
<p>
Get a record, update it with <code>Ecto.Changeset</code>.
</p>
</div>
</div>

<div id="outline-container-orgc3b7192" class="outline-4">
<h4 id="orgc3b7192"><span class="section-number-4">13.1.4</span> <a href="#orgc3b7192">insert children records as a whole</a></h4>
<div class="outline-text-4" id="text-13-1-4">
</div>
<div id="outline-container-orgf3ba0e5" class="outline-5">
<h5 id="orgf3ba0e5"><span class="section-number-5">13.1.4.1</span> <a href="#orgf3ba0e5">handling internal data</a></h5>
<div class="outline-text-5" id="text-13-1-4-1">
<p>
For handling internal data, we will use <code>Ecto.Changeset.put_assoc</code>. It takes a changeset, the name of association, and the records we want to put into the association:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>)
|&gt; <span class="org-type">Repo</span>.preload(<span class="org-elixir-atom">:posts</span>)
|&gt; change()
|&gt; put_assoc(<span class="org-elixir-atom">:posts</span>, [<span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"Software Design"</span>}])
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
Before making changes to existing associations, the association must be preloaded, just like above example code. But, if the parent record isn't inserted to database, preloading association can be ignored, such as:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">%Author</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Vicious"</span>}
|&gt; change()
|&gt; put_assoc(<span class="org-elixir-atom">:posts</span>, [
  <span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"12 Principles"</span>},
  <span class="org-type">%Post</span>{<span class="org-elixir-atom">title:</span> <span class="org-string">"Software Design"</span>}
])
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
Read more details at <code>h Ecto.Changeset.put_assoc</code>.
</p>
</div>
</div>

<div id="outline-container-orga938e2c" class="outline-5">
<h5 id="orga938e2c"><span class="section-number-5">13.1.4.2</span> <a href="#orga938e2c">handling external data</a></h5>
<div class="outline-text-5" id="text-13-1-4-2">
<p>
For handling external data, we will use <code>Ecto.Changeset.cast_assoc</code>. It takes a changeset and the name of association.
</p>

<p>
Moreover, a <code>changeset</code> function in associated schema is required by default, you can specify the function name with <code>with:</code> option.
</p>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">params</span> = %{
  <span class="org-string">"name"</span> =&gt; <span class="org-string">"Monica"</span>,
  <span class="org-string">"posts"</span> =&gt; [
    %{<span class="org-string">"title"</span> =&gt; <span class="org-string">"Hello World"</span>, <span class="org-string">"body"</span> =&gt; <span class="org-string">""</span>},
    %{<span class="org-string">"title"</span> =&gt; <span class="org-string">"Hello World"</span>, <span class="org-string">"body"</span> =&gt; <span class="org-string">""</span>}
  ]
}

<span class="org-type">%Author</span>{}
|&gt; cast(params, [<span class="org-elixir-atom">:name</span>])
|&gt; cast_assoc(<span class="org-elixir-atom">:posts</span>)
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
Read more details at <code>h Ecto.Changeset.cast_assoc</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org8db04de" class="outline-4">
<h4 id="org8db04de"><span class="section-number-4">13.1.5</span> <a href="#org8db04de">update children records as a whole</a></h4>
<div class="outline-text-4" id="text-13-1-5">
<p>
When updating children records as a whole, we are still using <code>Ecto.Changeset.put_assoc</code> and <code>Ecto.Changeset.cast_assoc</code>.
</p>

<p>
But, we should consider a question: <b>When updating, which action should be applied on children records which are replaced?</b>
</p>

<blockquote>
<p>
What is meaning of <span class="underline">being replaced</span>?
</p>

<p>
Imagine a author has many posts where the posts has IDs 1, 2 and 3. If you call <code>cast_assoc/3</code> passing only the IDs 1 and 2. Ecto will consider 3 is being <span class="underline">replaced</span>.
</p>

<p>
&#x2013; <a href="https://hexdocs.pm/ecto/3.4.4/Ecto.Changeset.html#module-the-on_replace-option">Official Doc of <code>Ecto.Changeset</code></a>
</p>
</blockquote>

<p>
<code>Ecto.Schema.*</code> provides <code>:on_replace</code> option to answer this question:
</p>
<ul class="org-ul">
<li><code>has_one</code> has <code>:raise</code> / <code>:mark_as_invaild</code> / <code>:nilify</code> / <code>:update</code> / <code>:delete</code>.</li>
<li><code>has_many</code> has <code>:raise</code> / <code>:mark_as_invaild</code> / <code>:nilify</code> / <code>:delete</code>.</li>
<li><code>many_to_many</code> has  <code>:raise</code> / <code>:mark_as_invaild</code> / <code>:delete</code>.</li>
</ul>

<div class="note">
<p>
<code>:on_replace</code> policy is triggered when calling <code>Ecto.Changeset.put_assoc</code> and <code>Ecto.Changeset.cast_assoc</code>.
</p>

</div>

<p>
Read more details in the <b>Associations, embeds and on replace</b> section of <code>h Ecto.Changeset</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org28e84e9" class="outline-3">
<h3 id="org28e84e9"><span class="section-number-3">13.2</span> <a href="#org28e84e9">Query</a></h3>
<div class="outline-text-3" id="text-13-2">
</div>
<div id="outline-container-orgfe23c00" class="outline-4">
<h4 id="orgfe23c00"><span class="section-number-4">13.2.1</span> <a href="#orgfe23c00">load associations</a></h4>
<div class="outline-text-4" id="text-13-2-1">
<p>
Associations must be preloaded manually.
</p>

<div class="note">
<p>
Ecto doesn't support lazy loading, we have to preload association manually. It helps to avoid N+1 querying problem.
</p>

</div>

<p>
Load associations when querying:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from <span class="org-type">Author</span>, <span class="org-elixir-atom">preload:</span> <span class="org-elixir-atom">:posts</span>
<span class="org-variable-name">authors</span> = <span class="org-type">Repo</span>.all(query)
</pre>
</div>

<p>
Load associations after querying:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">authors</span> = <span class="org-type">Author</span>
|&gt; <span class="org-type">Repo</span>.all()
|&gt; <span class="org-type">Repo</span>.preload(<span class="org-elixir-atom">:posts</span>)
</pre>
</div>

<p>
Above two methods will query database twice regardless of the count of authors:
</p>
<ul class="org-ul">
<li>one for getting all authors</li>
<li>one for getting all posts</li>
</ul>

<p>
If you wanna get authors and associated posts in one query, <code>join</code> can help you:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from a <span class="org-keyword">in</span> <span class="org-type">Author</span>,
  <span class="org-elixir-atom">join:</span> p <span class="org-keyword">in</span> assoc(a, <span class="org-elixir-atom">:posts</span>),
  <span class="org-elixir-atom">where:</span> p.title == <span class="org-string">"Hello World"</span>,
  <span class="org-elixir-atom">preload:</span> [<span class="org-elixir-atom">posts:</span> p]

<span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>

<div id="outline-container-org3f91b97" class="outline-4">
<h4 id="org3f91b97"><span class="section-number-4">13.2.2</span> <a href="#org3f91b97">load associations only</a></h4>
<div class="outline-text-4" id="text-13-2-2">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">author</span> = <span class="org-type">Repo</span>.get_by(<span class="org-type">Author</span>, %{<span class="org-elixir-atom">name:</span> <span class="org-string">"Spike"</span>})

<span class="org-variable-name">query</span> = <span class="org-type">Ecto</span>.assoc(author, <span class="org-elixir-atom">:posts</span>)
<span class="org-type">Repo</span>.all(query)
</pre>
</div>
</div>
</div>

<div id="outline-container-org7efec0d" class="outline-4">
<h4 id="org7efec0d"><span class="section-number-4">13.2.3</span> <a href="#org7efec0d">load nested associations</a></h4>
<div class="outline-text-4" id="text-13-2-3">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-variable-name">query</span> = from <span class="org-type">Artist</span>, <span class="org-elixir-atom">preload:</span> [<span class="org-elixir-atom">posts:</span> <span class="org-elixir-atom">:comments</span>]

<span class="org-variable-name">artists</span> = <span class="org-type">Repo</span>.all(query)
</pre>
</div>

<p>
Ecto will return all artists with posts, and all comments in posts.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd2734bd" class="outline-3">
<h3 id="orgd2734bd"><span class="section-number-3">13.3</span> <a href="#orgd2734bd">Delete</a></h3>
<div class="outline-text-3" id="text-13-3">
</div>
<div id="outline-container-org2061584" class="outline-4">
<h4 id="org2061584"><span class="section-number-4">13.3.1</span> <a href="#org2061584">delete a child record</a></h4>
<div class="outline-text-4" id="text-13-3-1">
<p>
Get a record, delete it.
</p>
</div>
</div>

<div id="outline-container-orga9d75a5" class="outline-4">
<h4 id="orga9d75a5"><span class="section-number-4">13.3.2</span> <a href="#orga9d75a5">delete a parent record</a></h4>
<div class="outline-text-4" id="text-13-3-2">
<p>
If a parent record has no child record, it is safe to delete it.
</p>

<p>
But, if a parent record has children records, you have to consider a question: <b><b>which action should be applied on its children records when deleting the parent record?</b></b>
</p>

<p>
<a href="#the-options-of-references">The <code>:on_delete</code> option of <code>Ecto.Migration.references</code></a> provides the answer to this question.
</p>

<p>
When using <code>:nothing</code> policy, Ecto will raise an constraint error when checking constraint. If you think the error is valuable for users, or it can be fixed by users, you can use one of following constraints to catch this errorthen convert it to human-readable message:
</p>
<ul class="org-ul">
<li><code>Ecto.Changeset.foreign_key_constraint</code></li>
<li><code>Ecto.Changeset.no_assoc_constraint</code></li>
</ul>

<div class="warn">
<p>
<code>has_one</code> / <code>has_many</code> / <code>many_to_many</code> in <code>Ecto.Schema</code> provide <code>:on_delete</code> option, too. But, you <b><b>SHOULD NEVER USE THEM</b></b>. Because these options:
</p>
<ul class="org-ul">
<li>CAN NOT guarantee database integrity.</li>
<li>only triggered by <code>Ecto.Repo.delete/2</code>, not including <code>Ecto.Repo.delete_all/2</code>.</li>
</ul>

</div>
</div>
</div>
</div>
</div>

<div id="outline-container-orgad8b6e7" class="outline-2">
<h2 id="orgad8b6e7"><span class="section-number-2">14</span> <a href="#orgad8b6e7">Transactions</a></h2>
<div class="outline-text-2" id="text-14">
<p>
Ecto supports transactions through <code>Repo.transcation</code>. There are 2 ways to call this function:
</p>
<ul class="org-ul">
<li>with a function containing the operations will be run within the transaction.</li>
<li>with <code>Ecto.Multi</code></li>
</ul>
</div>

<div id="outline-container-orgdedb4fb" class="outline-3">
<h3 id="orgdedb4fb"><span class="section-number-3">14.1</span> <a href="#orgdedb4fb">with a function</a></h3>
<div class="outline-text-3" id="text-14-1">
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">import</span> <span class="org-type">Ecto.Changeset</span>, <span class="org-elixir-atom">only:</span> [<span class="org-elixir-atom">change:</span> 2]

<span class="org-type">Repo</span>.transaction(<span class="org-keyword">fn</span> -&gt;
  <span class="org-type">Repo</span>.update!(change(alice, <span class="org-elixir-atom">balance:</span> alice.balance - 10))
  <span class="org-type">Repo</span>.update!(change(bob, <span class="org-elixir-atom">balance:</span> bob.balance + 10))
<span class="org-keyword">end</span>)
</pre>
</div>

<p>
When a transaction succeeds, <code>Repo.transaction</code> returns a tuple <code>{:ok, return_value_of_the_function}</code>.
</p>

<p>
When a transaction fails:
</p>
<ul class="org-ul">
<li>if an error is raised from the given function:
<ul class="org-ul">
<li>the transaction will be rolled back automatically.</li>
<li>the error will bubble up.</li>
</ul></li>
<li>if no error is raised from the given function:
<ul class="org-ul">
<li>the transaction will NOT be rolled back automatically. Rollback should be specified explicitly with <code>Repo.rollback/1</code>.</li>
<li><code>Repo.transaction</code> returns a tuple <code>{:error, value_specified_by_Repo_rollback}</code>.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org18f3bc6" class="outline-3">
<h3 id="org18f3bc6"><span class="section-number-3">14.2</span> <a href="#org18f3bc6">with <code>Ecto.Multi</code></a></h3>
<div class="outline-text-3" id="text-14-2">
<p>
<code>Ecto.Multi</code> groups database operations into a data structure. Compare to the plain function described above, it has some advantages:
</p>
<ul class="org-ul">
<li>you don't have to call Repo functions in the correct way carefully.</li>
<li>write less code.</li>
<li>easy to read.</li>
<li>&#x2026;</li>
</ul>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">alias</span> <span class="org-type">Ecto.Multi</span>

<span class="org-variable-name">multi</span> = <span class="org-type">Multi</span>.new
|&gt; <span class="org-type">Multi</span>.update(<span class="org-elixir-atom">:from</span>, change(alice, <span class="org-elixir-atom">balance:</span> alice.balance - 10))
|&gt; <span class="org-type">Multi</span>.update(<span class="org-elixir-atom">:to</span>, change(bob, <span class="org-elixir-atom">balance:</span> bob.balance + 10))
<span class="org-type">Repo</span>.transaction(multi)
</pre>
</div>

<div class="note">
<p>
Always create <code>%Ecto.Multi{}</code> with <code>Ecto.Multi.new/0</code> rather than <code>%Ecto.Multi{}</code>.
</p>

</div>

<p>
When a transaction succeeds, <code>Repo.transaction</code>  returns a tuple with <code>:ok</code> and a map. The keys in the map are the unique names we provided to each operation in the Multi. The values are the return values for each of those operations. This makes it easy for us to grab the return values of any or all of the operations we ran.
</p>

<p>
When a transaction fails and you are using changesets,  <code>Repo.transaction</code> returns a tuple with 4 items:
</p>
<ul class="org-ul">
<li><code>:error</code></li>
<li>the failed operation name, like above <code>:from</code> or <code>:to</code></li>
<li>the value that caused failure</li>
<li>a map containing changes to database (the changes have been rolled back, but Ecto provides them for you to inspect)</li>
</ul>

<div class="note">
<p>
Ecto is designed to not waste database time. If the <code>Ecto.Multi</code> contains operations that use changesets, Ecto will make sure all the changesets are valid. If any are not, Ecto will not run a transaction at all.
</p>

</div>

<p>
When a transaction fails with an raised error:
</p>
<ul class="org-ul">
<li>the transaction will be rolled back automatically.</li>
<li>the error will bubble up.</li>
</ul>
</div>
</div>

<div id="outline-container-org5c40200" class="outline-3">
<h3 id="org5c40200"><span class="section-number-3">14.3</span> <a href="#org5c40200">which one should I use?</a></h3>
<div class="outline-text-3" id="text-14-3">
<blockquote>
<p>
If you are only running a small number of operations and don't need to take different action depending on which operation succeeds or fails, using transaction with a function is enough.
</p>

<p>
For all other cases, you should consider <code>Ecto.Multi</code>. It has a lot more flexibility, and the code needed to respond to different types of errors will be much cleaner and easier to follow.
</p>

<p>
&#x2013; Programming Ecto
</p>
</blockquote>
</div>
</div>

<div id="outline-container-orgc7b723f" class="outline-3">
<h3 id="orgc7b723f"><span class="section-number-3">14.4</span> <a href="#orgc7b723f">executing non-database operations</a></h3>
<div class="outline-text-3" id="text-14-4">
<p>
Because Ecto don't know how to rollback non-database operations, you should run all of database operations first, then run non-database operations.
</p>
</div>

<div id="outline-container-org30ac5ed" class="outline-4">
<h4 id="org30ac5ed"><span class="section-number-4">14.4.1</span> <a href="#org30ac5ed">with a function</a></h4>
<div class="outline-text-4" id="text-14-4-1">
<div class="note">
<p>
Using <code>Ecto.Multi</code> for non-database operations is recommended.
</p>

</div>
</div>
</div>

<div id="outline-container-orgeec9eeb" class="outline-4">
<h4 id="orgeec9eeb"><span class="section-number-4">14.4.2</span> <a href="#orgeec9eeb">with <code>Ecto.Multi</code></a></h4>
<div class="outline-text-4" id="text-14-4-2">
<p>
Read <code>h Ecto.Multi.run</code> for more details.
</p>
</div>
</div>
</div>

<div id="outline-container-org3796a09" class="outline-3">
<h3 id="org3796a09"><span class="section-number-3">14.5</span> <a href="#org3796a09">introspecting <code>Ecto.Multi</code></a></h3>
<div class="outline-text-3" id="text-14-5">
<p>
<code>%Ecto.Multi{}</code> is a data structure that can be introspected.
</p>

<p>
Ecto team discourages inspecting or manipulating <code>%Ecto.Multi{}</code> directly, because the exact structure is subject to change.
</p>

<p>
Ecto team provides a function to introspect operations stored in <code>%Ecto.Multi{}</code>, read more details at <code>Ecto.Multi.to_list/1</code>.
</p>
</div>
</div>
</div>

<div id="outline-container-org99a7e24" class="outline-2">
<h2 id="org99a7e24"><span class="section-number-2">15</span> <a href="#org99a7e24">Seeding</a></h2>
<div class="outline-text-2" id="text-15">
<p>
Seeding is a mechanism to populate tables with relevant data programatically.
</p>

<p>
In Elixir, we can create a script to do this, and make sure that seed scripts is idempotent, because they may be executed multiple times.
</p>
</div>

<div id="outline-container-orgafdabb4" class="outline-3">
<h3 id="orgafdabb4"><span class="section-number-3">15.1</span> <a href="#orgafdabb4">Handling uniqueness</a></h3>
<div class="outline-text-3" id="text-15-1">
<p>
You may handling uniqueness problem in this way:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Repo</span>.get_by(<span class="org-type">Tag</span>, <span class="org-elixir-atom">name:</span> <span class="org-string">"Tech"</span>) || <span class="org-type">Repo</span>.insert!(<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Tech"</span>})
</pre>
</div>

<p>
But, above operation is unsafe - not an atomic operation. In certain conditions, Ecto will try to insert two same data at the same time, which will cause a database constraint error.
</p>

<p>
Instead, we shouldn't handle this uniqueness problem by ourselves. Just insert the data, and let database manage the conflict data - this feature is known as <b>upsert</b>.
</p>

<p>
In Ecto, the <b>upsert</b> feature is implemented as <code>:on_conflict</code> option of <code>Repo.insert!</code>. A possible example would be:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-comment-delimiter"># </span><span class="org-comment">ignore conflicting data</span>
<span class="org-type">Repo</span>.insert!(<span class="org-type">%Tag</span>{<span class="org-elixir-atom">name:</span> <span class="org-string">"Tech"</span>, <span class="org-elixir-atom">on_conflict:</span> <span class="org-elixir-atom">:nothing</span>})
</pre>
</div>

<p>
There are lots of available values for <code>:on_conflict</code> option, read more details at <code>h Repo.insert</code>.
</p>

<div class="note">
<p>
<b>Upsert</b> feature is often database specific, make sure that your database supports it before using.
</p>

<p>
PS: Choose PostgreSQL, everything will be fine.
</p>

</div>
</div>
</div>

<div id="outline-container-orga5143d2" class="outline-3">
<h3 id="orga5143d2"><span class="section-number-3">15.2</span> <a href="#orga5143d2">Populate data with Schema</a></h3>
<div class="outline-text-3" id="text-15-2">
<p>
Data can be inserted with Schema easily, even associated data.
</p>

<div class="org-src-container">
<pre class="src src-elixir"><span class="org-type">Repo</span>.insert(
  <span class="org-type">%Author</span>{
    <span class="org-elixir-atom">name:</span> <span class="org-string">"Jet"</span>,
    <span class="org-elixir-atom">posts:</span> [
      <span class="org-type">%Post</span>{
        <span class="org-elixir-atom">title:</span> <span class="org-string">"Hello World!"</span>,
        <span class="org-elixir-atom">body:</span> <span class="org-string">"Here you go!"</span>
      }
    ]
  }
)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf110568" class="outline-2">
<h2 id="orgf110568"><span class="section-number-2">16</span> <a href="#orgf110568">Appendix</a></h2>
<div class="outline-text-2" id="text-16">
</div>
<div id="outline-container-org1c83038" class="outline-3">
<h3 id="org1c83038"><span class="section-number-3">16.1</span> <a href="#org1c83038">Naming conventions</a></h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>Migration
<ul class="org-ul">
<li>tables' name - <code>pluralized_name</code></li>
</ul></li>
<li>Schema
<ul class="org-ul">
<li>module name - <code>SnakeSingularizedName</code></li>
<li>file name - <code>underscore_singularized_name</code></li>
<li>functions' arguments - <code>attrs</code></li>
</ul></li>
<li>Context
<ul class="org-ul">
<li>module - <code>SnakePluralizedName</code></li>
<li>file name - <code>underscore_pluralized_name</code></li>
<li>functions' arguments - <code>attrs</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org79f6a91" class="outline-3">
<h3 id="org79f6a91"><span class="section-number-3">16.2</span> <a href="#org79f6a91">Related Mix tasks</a></h3>
<div class="outline-text-3" id="text-16-2">
<p>
Repo related:
</p>
<ul class="org-ul">
<li><code>ecto.gen.repo</code>: Generates a new repository.</li>
</ul>

<p>
Database related:
</p>
<ul class="org-ul">
<li><code>ecto.create</code>: Creates the repository storage.</li>
<li><code>ecto.drop</code>:  Drops the repository storage.</li>
</ul>

<p>
Dump related:
</p>
<ul class="org-ul">
<li><code>ecto.dump</code>: Dumps the repository database structure.</li>
<li><code>ecto.load</code>: Loads previously dumped database structure.</li>
</ul>

<p>
Migration related:
</p>
<ul class="org-ul">
<li><code>ecto.gen.migration</code>: Generates a new migration for the repo.</li>
<li><code>ecto.migrations</code>: Displays the repository migration status.</li>
<li><code>ecto.migrate</code>: Runs the repository migrations.</li>
<li><code>ecto.rollback</code>: Rolls back the repository migrations.</li>
</ul>

<p>
Common aliases:
</p>
<ul class="org-ul">
<li><code>ecto.setup</code> - An alias defined in <code>mix.exs</code>, generally:
<ul class="org-ul">
<li><code>mix ecto.create</code></li>
<li><code>mix ecto.migrate</code></li>
<li><code>mix run priv/repo/seeds.exs</code></li>
</ul></li>
<li><code>ecto.reset</code> - An alias defined in <code>mix.exs</code>, generally:
<ul class="org-ul">
<li><code>mix ecto.drop</code></li>
<li><code>mix ecto.setup</code></li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org2722025" class="outline-3">
<h3 id="org2722025"><span class="section-number-3">16.3</span> <a href="#org2722025">Schema related tips</a></h3>
<div class="outline-text-3" id="text-16-3">
</div>
<div id="outline-container-org337abb1" class="outline-4">
<h4 id="org337abb1"><span class="section-number-4">16.3.1</span> <a href="#org337abb1">#1</a></h4>
<div class="outline-text-4" id="text-16-3-1">
<p>
In Ecto, a table is not coupled to only one schema, we can create more than one schema for a table.
</p>
</div>
</div>

<div id="outline-container-orgbe467b2" class="outline-4">
<h4 id="orgbe467b2"><span class="section-number-4">16.3.2</span> <a href="#orgbe467b2">#2</a></h4>
<div class="outline-text-4" id="text-16-3-2">
<p>
In Ecto, a schema is not coupled to only one update policy, we can create more than one update policies for a schema. Each update policy has its own separate <code>changeset/2</code> function.
</p>
</div>
</div>
</div>

<div id="outline-container-org90936fd" class="outline-3">
<h3 id="org90936fd"><span class="section-number-3">16.4</span> <a href="#org90936fd">About timestamps</a></h3>
<div class="outline-text-3" id="text-16-4">
<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Migration Type</th>
<th scope="col" class="org-left">Postgres type</th>
<th scope="col" class="org-left">Store microseconds?</th>
<th scope="col" class="org-left">Support DateTime functions?</th>
<th scope="col" class="org-left">Support NaiveDateTime functions?</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left"><code>:utc_datetime_usec</code></td>
<td class="org-left"><code>timestamp without time zone</code></td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left"><code>:naive_datetime_usec</code></td>
<td class="org-left"><code>timestamp without time zone</code></td>
<td class="org-left">Yes</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left"><code>:utc_datetime</code></td>
<td class="org-left"><code>timestamp without time zone(0)</code></td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
<td class="org-left">Yes</td>
</tr>

<tr>
<td class="org-left"><code>:naive_datetime</code></td>
<td class="org-left"><code>timestamp without time zone(0)</code></td>
<td class="org-left">No</td>
<td class="org-left">No</td>
<td class="org-left">Yes</td>
</tr>
</tbody>
</table>

<p>
By default, Ecto use :naive<sub>datetime</sub> and don't preserve microsecond information.
</p>
</div>

<div id="outline-container-org8118c63" class="outline-4">
<h4 id="org8118c63"><span class="section-number-4">16.4.1</span> <a href="#org8118c63">What is the meaning of <code>(0)</code>?</a></h4>
<div class="outline-text-4" id="text-16-4-1">
<p>
<code>(0)</code> means that fractional seconds are not stored.
</p>
</div>
</div>

<div id="outline-container-org99649eb" class="outline-4">
<h4 id="org99649eb"><span class="section-number-4">16.4.2</span> <a href="#org99649eb">Use <code>:utc_datetime_usec</code> globally</a></h4>
<div class="outline-text-4" id="text-16-4-2">
<p>
Apply on Migrations via configuration of Repo:
</p>
<div class="org-src-container">
<pre class="src src-elixir">config <span class="org-elixir-atom">:paper</span>, <span class="org-type">Paper.Repo</span>, <span class="org-elixir-atom">migration_timestamps:</span> [<span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:utc_datetime_usec</span>]
</pre>
</div>

<p>
Apply on schemas according to <a href="https://hexdocs.pm/ecto/Ecto.Schema.html#module-schema-attributes">official docs</a>:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-comment-delimiter"># </span><span class="org-comment">Define a module to be used as base</span>
<span class="org-keyword">defmodule</span> <span class="org-type">Paper.Schema</span> <span class="org-keyword">do</span>
  <span class="org-keyword">defmacro</span> __using__(<span class="org-constant">_</span>) <span class="org-keyword">do</span>
    <span class="org-keyword">quote</span> <span class="org-keyword">do</span>
      <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>
      <span class="org-elixir-attribute">@timestamps_opts</span> [<span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:utc_datetime_usec</span>]
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>

<span class="org-comment-delimiter"># </span><span class="org-comment">Use MyApp.Schema to define new schemas</span>
<span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Comment</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Paper.Schema</span>

  schema <span class="org-string">"comments"</span> <span class="org-keyword">do</span>
    timestamps()
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orge31f703" class="outline-4">
<h4 id="orge31f703"><span class="section-number-4">16.4.3</span> <a href="#orge31f703">Use <code>:utc_datetime_usec</code> locally</a></h4>
<div class="outline-text-4" id="text-16-4-3">
<p>
Apply on Migrations:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.Repo.Migrations.CreateComments</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Migration</span>

  <span class="org-keyword">def</span> <span class="org-function-name">change</span> <span class="org-keyword">do</span>
    create table(<span class="org-string">"comments"</span>) <span class="org-keyword">do</span>
      <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

      timestamps(<span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:utc_datetime_usec</span>)
    <span class="org-keyword">end</span>
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>

<p>
Apply on Schemas:
</p>
<div class="org-src-container">
<pre class="src src-elixir"><span class="org-keyword">defmodule</span> <span class="org-type">Paper.CMS.Comment</span> <span class="org-keyword">do</span>
  <span class="org-keyword">use</span> <span class="org-type">Ecto.Schema</span>

  schema <span class="org-string">"comments"</span> <span class="org-keyword">do</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">...</span>

    timestamps(<span class="org-elixir-atom">type:</span> <span class="org-elixir-atom">:utc_datetime_usec</span>)
  <span class="org-keyword">end</span>
<span class="org-keyword">end</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org84a4b01" class="outline-3">
<h3 id="org84a4b01"><span class="section-number-3">16.5</span> <a href="#org84a4b01">Setting default value for fields?</a></h3>
<div class="outline-text-3" id="text-16-5">
</div>
<div id="outline-container-orgc95a373" class="outline-4">
<h4 id="orgc95a373"><span class="section-number-4">16.5.1</span> <a href="#orgc95a373">set default value in database level</a></h4>
<div class="outline-text-4" id="text-16-5-1">
<p>
Set default value for columns by using <code>:default</code> option of <code>add</code> macro in <code>Ecto.Migration</code>.
</p>

<div class="note">
<p>
Furthermore, the default value set in this way is used when inserting new rows, including:
</p>
<ul class="org-ul">
<li>insert new rows.</li>
<li>insert new columns for existing rows.</li>
</ul>

</div>
</div>
</div>

<div id="outline-container-org6e74ff8" class="outline-4">
<h4 id="org6e74ff8"><span class="section-number-4">16.5.2</span> <a href="#org6e74ff8">set default value in application level</a></h4>
<div class="outline-text-4" id="text-16-5-2">
<p>
There're two ways to set default value in application level:
</p>
<ul class="org-ul">
<li>use <code>:default</code> option of <code>field</code> macro in <code>Ecto.Schema</code>.</li>
<li>use <code>Ecto.Changeset.put_change</code> or similar functions.</li>
</ul>

<p>
Default values set by <code>:default</code> option will be evaluated at compilation time, so you shouldn't use them if you need dynamic values.
</p>

<div class="note">
<p>
<code>Ecto.Changeset.put_change</code> or similar functions is preferred in this case.
</p>

</div>
</div>
</div>

<div id="outline-container-org779da9a" class="outline-4">
<h4 id="org779da9a"><span class="section-number-4">16.5.3</span> <a href="#org779da9a">which one should I use?</a></h4>
<div class="outline-text-4" id="text-16-5-3">
<p>
If you have multiple applications using the same database, and:
</p>
<ul class="org-ul">
<li>if they need same default values, default values can be set in schemas or migrations.</li>
<li>if they need different default values, default values should be set in schemas.</li>
</ul>

<p>
If you only have one application, default values can be set in schemas or migrations.
</p>

<p>
When possible, I prefer using schemas. Because in this way, I can reduce the frequency of changing database, which makes me iterate application faster.
</p>
</div>
</div>
</div>

<div id="outline-container-orgee27fb3" class="outline-3">
<h3 id="orgee27fb3"><span class="section-number-3">16.6</span> <a href="#orgee27fb3">Commonly used constraints</a></h3>
<div class="outline-text-3" id="text-16-6">
<p>
We have known the usage of <code>unique_constraint/3</code>. In this section, we will introduce other commonly used constraints.
</p>
</div>

<div id="outline-container-org9479043" class="outline-4">
<h4 id="org9479043"><span class="section-number-4">16.6.1</span> <a href="#org9479043"><code>foreign_key_constraint/3</code></a></h4>
<div class="outline-text-4" id="text-16-6-1">
<p>
This function checks foreign key constraint in the given field.
</p>

<p>
When inserting / updating a post, check if the foreign key is valid:
</p>
<div class="org-src-container">
<pre class="src src-elixir">post
|&gt; change()
|&gt; foreign_key_constraint(<span class="org-elixir-atom">:author_id</span>)
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>

<p>
When deleting a author, check if there's no associated post:
</p>
<div class="org-src-container">
<pre class="src src-elixir">author
|&gt; change()
|&gt; foreign_key_constraint(
  <span class="org-elixir-atom">:posts</span>,
  <span class="org-elixir-atom">name:</span> <span class="org-elixir-atom">:posts_author_id_fkey</span>,
  <span class="org-elixir-atom">message:</span> <span class="org-string">"still exists"</span>
)
|&gt; <span class="org-type">Repo</span>.delete!()
</pre>
</div>

<div class="note">
<p>
As you can see, using <code>foreign_key_contraint/3</code> when deleting a record, we have to define the contraint name manually. That is verbose. So I prefer using <code>no_assoc_constraint/3</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-org16ebf45" class="outline-4">
<h4 id="org16ebf45"><span class="section-number-4">16.6.2</span> <a href="#org16ebf45"><code>assoc_constraint/3</code></a></h4>
<div class="outline-text-4" id="text-16-6-2">
<p>
This function checks if the associated field exists. It is generally used when inserting or updating record.
</p>

<p>
<code>assoc_constraint/3</code> is similar to <code>foreign_key_constraint/3</code>, but field of foreign key is inferred from association definition rather than being specified exactly.
</p>

<p>
When inserting / updating a post, check if the foreign key is valid:
</p>
<div class="org-src-container">
<pre class="src src-elixir">post
|&gt; change()
|&gt; assoc_constraint(<span class="org-elixir-atom">:author</span>) // infer the foreign key from association name
|&gt; <span class="org-type">Repo</span>.insert!()
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd2ffacb" class="outline-4">
<h4 id="orgd2ffacb"><span class="section-number-4">16.6.3</span> <a href="#orgd2ffacb"><code>no_assoc_constraint/3</code></a></h4>
<div class="outline-text-4" id="text-16-6-3">
<p>
Check the associated field doesn't exist. It is generally used when deleting record.
</p>

<p>
Define the foreign key:
</p>
<div class="org-src-container">
<pre class="src src-elixir">create table(<span class="org-string">"posts"</span>) <span class="org-keyword">do</span>
  add <span class="org-elixir-atom">:author_id</span>, references(<span class="org-string">"authors"</span>)
<span class="org-keyword">end</span>
</pre>
</div>

<p>
When deleting a record, check if no child exists:
</p>
<div class="org-src-container">
<pre class="src src-elixir">author
|&gt; change()
|&gt; no_assoc_constraint(<span class="org-elixir-atom">:posts</span>)
|&gt; <span class="org-type">Repo</span>.delete!()
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org866bc11" class="outline-3">
<h3 id="org866bc11"><span class="section-number-3">16.7</span> <a href="#org866bc11">Don't use constraints all the time</a></h3>
<div class="outline-text-3" id="text-16-7">
<blockquote>
<p>
Using changeset constraints only makes sense if the error message can be something the user can take action on.
</p>
</blockquote>

<p>
Constraints is useful when converting error into human-readable messages. But you don't have to use them all the time.
</p>

<p>
Actually, our above example isn't very well. In a blogging system, every post should have a author. If not, it can only be a bug in our application or a data-integrity issue. In such case, the user can do nothing to fix the error, so crashing is the best option. You shouldn't convert such kind of error into human-readable messages any more.
</p>
</div>
</div>
</div>

<div id="outline-container-orgafc3963" class="outline-2">
<h2 id="orgafc3963"><span class="section-number-2">17</span> <a href="#orgafc3963">License</a></h2>
<div class="outline-text-2" id="text-17">
<p>
This book is restricted by <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en">CC BY-NC-SA 4.0</a>.
</p>
</div>
</div>
</div>
</body>
</html>
